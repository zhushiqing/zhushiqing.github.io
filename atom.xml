<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[SunnyZhu'blog]]></title>
  <subtitle><![CDATA[不要让自己的未来后悔，所以，努力吧！]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://zhushiqing.github.io/"/>
  <updated>2014-09-10T23:47:15.828Z</updated>
  <id>http://zhushiqing.github.io/</id>
  
  <author>
    <name><![CDATA[zhushiqing]]></name>
    <email><![CDATA[zsq66zsq@163.com]]></email>
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Java的内存回收机制]]></title>
    <link href="http://zhushiqing.github.io/2014/09/03/JVM/"/>
    <id>http://zhushiqing.github.io/2014/09/03/JVM/</id>
    <published>2014-09-03T11:47:11.000Z</published>
    <updated>2014-09-03T12:41:26.000Z</updated>
    <content type="html"><![CDATA[<p>在Java中，它的内存管理包括两方面：内存分配（创建Java对象的时候）和内存回收，这两方面工作都是由JVM自动完成<br>的，降低了Java程序员的学习难度，避免了像C/C++直接操作内存的危险。但是，也正因为内存管理完全由JVM负责，所以<br>也使Java很多程序员不再关心内存分配，导致很多程序低效，耗内存。因此就有了Java程序员到最后应该去了解JVM，才<br>能写出更高效，充分利用有限的内存的程序。</p>
<a id="more"></a>

<hr>
<h2 id="1-Java在内存中的状态">1.Java在内存中的状态</h2>
<p>首先我们先写一个代码为例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">Person类</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.Serializable;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>{</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1</span>L;</div><div class="line"></div><div class="line">    String name; <span class="comment">// 姓名</span></div><div class="line">    </div><div class="line">    Person friend;    <span class="comment">//朋友</span></div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="title">Person</span>() {}</div><div class="line">    </div><div class="line">    <span class="keyword">public</span> <span class="title">Person</span>(String name) {</div><div class="line">        <span class="keyword">super</span>();</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line">Test类</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>{</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {</div><div class="line">        Person p1 = <span class="keyword">new</span> Person(<span class="string">"Kevin"</span>);</div><div class="line">        Person p2 = <span class="keyword">new</span> Person(<span class="string">"Rain"</span>);</div><div class="line">        Person p3 = <span class="keyword">new</span> Person(<span class="string">"Sunny"</span>);</div><div class="line">        </div><div class="line">        p1.friend = p2;</div><div class="line">        p3 = p2;</div><div class="line">        p2 = <span class="keyword">null</span>;</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>把上面Test.java中main方面里面的对象引用画成一个从main方法开始的对象引用图的话就是这样的（顶点是对象和引用，有向边是引用关系）：</p>
<p><img src="/image/140902-1.png" alt=""><br>当程序运行起来之后，把它在内存中的状态看成是有向图后，可以分为三种：</p>
<blockquote>
<p>1）可达状态：在一个对象创建后，有一个以上的引用变量引用它。在有向图中可以从起始顶点导航到该对象，那它就处于可达状态。</p>
<p>2）可恢复状态：如果程序中某个对象不再有任何的引用变量引用它，它将先进入可恢复状态，此时从有向图的起始顶点不能再导航到该对象。在这个状态下，系统的垃圾回收机制准备回收该对象的所占用的内存，在回收之前，系统会调用finalize()方法进行资源清理，如果资源整理后重新让一个以上引用变量引用该对象，则这个对象会再次变为可达状态；否则就会进入不可达状态。</p>
<p>3）不可达状态：当对象的所有关联都被切断，且系统调用finalize()方法进行资源清理后依旧没有使该对象变为可达状态，则这个对象将永久性失去引用并且变成不可达状态，系统才会真正的去回收该对象所占用的资源。</p>
</blockquote>
<p>上述三种状态的转换图如下：<br><img src="/image/140902-2.png" alt=""></p>
<hr>
<h2 id="2-Java对对象的4种引用">2.Java对对象的4种引用</h2>
<blockquote>
<p>1）强引用 ：创建一个对象并把这个对象直接赋给一个变量，eg ：Person person = new Person(“sunny”); 不管系统资源有么的紧张，强引用的对象都绝对不会被回收，即使他以后不会再用到。</p>
<p>2）软引用 ：通过SoftReference类实现，eg : SoftReference<person> p = new SoftReference<person>(new Person(“Rain”));,内存非常紧张的时候会被回收，其他时候不会被回收，所以在使用之前要判断是否为null从而判断他是否已经被回收了。</person></person></p>
<p>3）弱引用 ：通过WeakReference类实现，eg : WeakReference<person> p = new WeakReference<person>(new Person(“Rain”));不管内存是否足够，系统垃圾回收时必定会回收。</person></person></p>
<p>4）虚引用 ：不能单独使用，主要是用于追踪对象被垃圾回收的状态。通过PhantomReference类和引用队列ReferenceQueue类联合使用实现，eg ：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> test;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.lang.ref.PhantomReference;</div><div class="line"><span class="keyword">import</span> java.lang.ref.ReferenceQueue;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>{</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {</div><div class="line">        <span class="comment">//创建一个对象</span></div><div class="line">        Person person = <span class="keyword">new</span> Person(<span class="string">"Sunny"</span>);    </div><div class="line">        <span class="comment">//创建一个引用队列    </span></div><div class="line">        ReferenceQueue&lt;Person&gt; rq = <span class="keyword">new</span> ReferenceQueue&lt;Person&gt;();</div><div class="line">        <span class="comment">//创建一个虚引用，让此虚引用引用到person对象</span></div><div class="line">        PhantomReference&lt;Person&gt; pr = <span class="keyword">new</span> PhantomReference&lt;Person&gt;(person, rq);</div><div class="line">        <span class="comment">//切断person引用变量和对象的引用</span></div><div class="line">        person = <span class="keyword">null</span>;</div><div class="line">        <span class="comment">//试图取出虚引用所引用的对象</span></div><div class="line">        <span class="comment">//发现程序并不能通过虚引用访问被引用对象，所以此处输出为null</span></div><div class="line">        System.out.println(pr.get());</div><div class="line">        <span class="comment">//强制垃圾回收</span></div><div class="line">        System.gc();</div><div class="line">        System.runFinalization();</div><div class="line">        <span class="comment">//因为一旦虚引用中的对象被回收后，该虚引用就会进入引用队列中</span></div><div class="line">        <span class="comment">//所以用队列中最先进入队列中引用与pr进行比较，输出true</span></div><div class="line">        System.out.println(rq.poll() == pr);</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<hr>
<h2 id="3-Java垃圾回收机制">3.Java垃圾回收机制</h2>
<p>其实Java垃圾回收主要做的是两件事：1）内存回收 2）碎片整理</p>
<h3 id="3-1垃圾回收算法">3.1垃圾回收算法</h3>
<p>1）串行回收（只用一个CPU）和并行回收（多个CPU才有用）：串行回收是不管系统有多少个CPU，始终只用一个CPU来执行垃圾回收操作，而并行回收就是把整个回收工作拆分成多个部分，每个部分由一个CPU负责，从而让多个CPU并行回收。并行回收的执行效率很高，但复杂度增加，另外也有一些副作用，如内存碎片增加。</p>
<p>2）并发执行和应用程序停止 ：应用程序停止（Stop-the-world）顾名思义，其垃圾回收方式在执行垃圾回收的同时会导致应用程序的暂停。并发执行的垃圾回收虽然不会导致应用程序的暂停，但由于并发执行垃圾需要解决和应用程序的执行冲突（应用程序可能在垃圾回收的过程修改对象），因此并发执行垃圾回收的系统开销比Stop-the-world高，而且执行时需要更多的堆内存。</p>
<p>3）压缩和不压缩和复制 ：</p>
<p>①支持压缩的垃圾回收器（标记-压缩 = 标记清除+压缩）会把所有的可达对象搬迁到一端，然后直接清理掉端边界以外的内存，减少了内存碎片。</p>
<p>②不压缩的垃圾回收器（标记-清除）要遍历两次，第一次先从跟开始访问所有可达对象，并将他们标记为可达状态，第二次便利整个内存区域，对未标记可达状态的对象进行回收处理。这种回收方式不压缩，不需要额外内存，但要两次遍历，会产生碎片</p>
<p>③复制式的垃圾回收器：将堆内存分成两个相同空间，从根（类似于前面的有向图起始顶点）开始访问每一个关联的可达对象，将空间A的全部可达对象复制到空间B，然后一次性回收空间A。对于该算法而言，因为只需访问所有的可达对象，将所有的可达对象复制走之后就直接回收整个空间，完全不用理会不可达对象，所以遍历空间的成本较小，但需要巨大的复制成本和较多的内存。</p>
<p><img src="/image/140902-3.png" alt=""></p>
<h3 id="3-2堆内存的分代回收">3.2堆内存的分代回收</h3>
<p>1）分代回收的依据：<br>①对象生存时间的长短：大部分对象在Young期间就被回收</p>
<p>②不同代采取不同的垃圾回收策略：新（生存时间短）老（生存时间长）对象之间很少存在引用</p>
<p>2) 堆内存的分代：<br>①Young代 ：</p>
<p>Ⅰ回收机制 ：因为对象数量少，所以采用复制回收。</p>
<p>Ⅱ组成区域 ：由1个Eden区和2个Survivor区构成，同一时间的两个Survivor区，一个用来保存对象，另一个是空的；每次进行Young代垃圾回收的时候，就把Eden，From中的可达对象复制到To区域中，一些生存时间长的就复制到了老年代，接着清除Eden，From空间，最后原来的To空间变为From空间，原来的From空间变为To空间。</p>
<p>Ⅲ对象来源 ：绝大多数对象先分配到Eden区，一些大的对象会直接被分配到Old代中。</p>
<p>Ⅳ回收频率 ：因为Young代对象大部分很快进入不可达状态，因此回收频率高且回收速度快<br><img src="/image/140902-4.png" alt=""><br><img src="/image/140902-5.png" alt=""><br>②Old代 ：</p>
<p>Ⅰ回收机制 ：采用标记压缩算法回收。</p>
<p>Ⅱ对象来源 ：1.对象大直接进入老年代。</p>
<p>　　　　　　 2.Young代中生存时间长的可达对象</p>
<p>Ⅲ回收频率 ：因为很少对象会死掉，所以执行频率不高，而且需要较长时间来完成。</p>
<p>③Permanent代 ：</p>
<p>Ⅰ用      途 ：用来装载Class，方法等信息，默认为64M，不会被回收</p>
<p>Ⅱ对象来源 ：eg：对于像Hibernate，Spring这类喜欢AOP动态生成类的框架，往往会生成大量的动态代理类，因此需要更多的Permanent代内存。所以我们经常在调试Hibernate，Spring的时候经常遇到java.lang.OutOfMemoryError:PermGen space的错误，这就是Permanent代内存耗尽所导致的错误。</p>
<p>Ⅲ回收频率 ：不会被回收</p>
<h3 id="3-3常见的垃圾回收器">3.3常见的垃圾回收器</h3>
<p>在此之前，我们先讲一下下面将会涉及到的并发和并行两个词的解释：</p>
<p>1）并行：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态；</p>
<p>2）并发：指用户线程与 垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），用户程序继续执行，而垃圾收集程序运行于另一个CPU上。</p>
<p>好啦，继续讲垃圾回收器：</p>
<p>1）串行回收器（只使用一个CPU）：Young代采用串行复制算法；Old代使用串行标记压缩算法（三个阶段：标记mark—清除sweep—压缩compact），回收期间程序会产生暂停，</p>
<p>2）并行回收器：对Young代采用的算法和串行回收器一样，只是增加了多CPU并行处理； 对Old代的处理和串行回收器完全一样，依旧是单线程。</p>
<p>3）并行压缩回收器：对Young代处理采用与并行回收器完全一样的算法；只是对Old代采用了不同的算法，其实就是划分不同的区域，然后进行标记压缩算法：</p>
<p>① 将Old代划分成几个固定区域；</p>
<p>② mark阶段（多线程并行），标记可达对象；</p>
<p>③ summary阶段（串行执行），从最左边开始检验知道找到某个达到数值（可达对象密度小）的区域时，此区域及其右边区域进行压缩回收，其左端为密集区域</p>
<p>④ compact阶段（多线程并行），识别出需要装填的区域，多线程并行的把数据复制到这些区域中。经此过程后，Old代一端密集存在大量活动对象，另一端则存在大块空间。</p>
<p>4）并发标识—清理回收（CMS）：对Young代处理采用与并行回收器完全一样的算法；只是对Old代采用了不同的算法，但归根待地还是标记清理算法：</p>
<p>① 初始标识（程序暂停）：标记被直接引用的对象(一级对象)；</p>
<p>② 并发标识（程序运行）：通过一级对象寻找其他可达对象；</p>
<p>③ 再标记（程序暂停）：多线程并行的重新标记之前可能因为并发而漏掉的对象（简单的说就是防遗漏）</p>
<p>④ 并发清理（程序运行）</p>
<h2 id="4-内存管理小技巧">4.内存管理小技巧</h2>
<p>1）尽量使用直接量，eg：String javaStr = “XXXX”;</p>
<p>2）使用StringBuilder和StringBuffer进行字符串连接等操作;</p>
<p>3）尽早释放无用对象;</p>
<p>4）尽量少使用静态变量;</p>
<p>5）缓存常用的对象:可以使用开源的开源缓存实现，eg：OSCache，Ehcache;</p>
<p>6）尽量不使用finalize()方法;</p>
<p>7）在必要的时候可以考虑使用软引用SoftReference。</p>
<p>转载自<a href="http://www.cnblogs.com/xiaoxuetu/" target="_blank" rel="external">http://www.cnblogs.com/xiaoxuetu/</a> </p>
]]></content>
    <summary type="html"><![CDATA[<p>在Java中，它的内存管理包括两方面：内存分配（创建Java对象的时候）和内存回收，这两方面工作都是由JVM自动完成<br>的，降低了Java程序员的学习难度，避免了像C/C++直接操作内存的危险。但是，也正因为内存管理完全由JVM负责，所以<br>也使Java很多程序员不再关心内存分配，导致很多程序低效，耗内存。因此就有了Java程序员到最后应该去了解JVM，才<br>能写出更高效，充分利用有限的内存的程序。</p>
]]></summary>
    
      <category term="Java" scheme="http://zhushiqing.github.io/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ArrayList的实现原理]]></title>
    <link href="http://zhushiqing.github.io/2014/09/01/arraylist/"/>
    <id>http://zhushiqing.github.io/2014/09/01/arraylist/</id>
    <published>2014-09-01T14:43:34.000Z</published>
    <updated>2014-09-01T22:29:48.000Z</updated>
    <content type="html"><![CDATA[<h2 id="1-ArrayList概述">1.ArrayList概述</h2>
<pre><code>ArrayList是Lits可变数组的一种实现。实现了所有可选列表操作，并允许包括 <span class="literal">null</span> 在内的所有元素。除了实现 
</code></pre><p>List 接口外，此类还提供一些方法来操作内部用来存储列表的数组的大小。<br>    每个ArrayList实例都有一个容量，该容量是指用来存储列表元素的数组的大小。它总是至少等于列表的大小。随着向<br>ArrayList中不断添加元素，其容量也自动增长。自动增长会带来数据向新数组的重新拷贝，因此，如果可预知数据量的多<br>少，可在构造ArrayList时指定其容量。在添加大量元素前，应用程序也可以使用ensureCapacity操作来增加ArrayList<br>实例的容量，这可以减少递增式再分配的数量。<br>       注意，此实现不是同步的。如果多个线程同时访问一个ArrayList实例，而其中至少一个线程从结构上修改了列表，<br>那么它必须保持外部同步。</p>
<a id="more"></a>

<h2 id="2-ArrayList实现">2.ArrayList实现</h2>
<p>对于ArrayList而言，它实现List接口、底层使用数组保存所有元素。其操作基本上是对数组的操作。下面我们来分析<br>ArrayList的源代码：</p>
<h3 id="1)_底层使用数组实现:">1) 底层使用数组实现:</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Object[] elementData;</div></pre></td></tr></table></figure>

<hr>
<h3 id="2)_构造方法:">2) 构造方法:</h3>
<p> ArrayList提供了三种方式的构造器，可以构造一个默认初始容量为10的空列表、构造一个指定初始容量的空列表以及构<br> 造一个包含指定collection的元素的列表，这些元素按照该collection的迭代器返回它们的顺序排列的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="title">ArrayList</span>() {   </div><div class="line">    <span class="keyword">this</span>(<span class="number">10</span>);   </div><div class="line">}   </div><div class="line">  </div><div class="line"><span class="keyword">public</span> <span class="title">ArrayList</span>(<span class="keyword">int</span> initialCapacity) {   </div><div class="line">    <span class="keyword">super</span>();   </div><div class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)   </div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+ initialCapacity);   </div><div class="line">    <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];   </div><div class="line">}   </div><div class="line">  </div><div class="line"><span class="keyword">public</span> <span class="title">ArrayList</span>(Collection&lt;? extends E&gt; c) {   </div><div class="line">    elementData = c.toArray();   </div><div class="line">    size = elementData.length;   </div><div class="line">    <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)   </span></div><div class="line">    <span class="keyword">if</span> (elementData.getClass() != Object[].class)   </div><div class="line">        elementData = Arrays.copyOf(elementData, size, Object[].class);   </div><div class="line">}</div></pre></td></tr></table></figure>

<hr>
<h3 id="3)_存储:">3) 存储:</h3>
<p>   ArrayList提供了set(int index, E element)、add(E e)、add(int index, E element)、<br>addAll(Collection&lt;? extends E&gt; c)、addAll(int index, Collection&lt;? extends E&gt; c)这些添加元素<br>的方法。下面我们一一讲解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 用指定的元素替代此列表中指定位置上的元素，并返回以前位于该位置上的元素。   </span></div><div class="line"><span class="keyword">public</span> E <span class="title">set</span>(<span class="keyword">int</span> index, E element) {   </div><div class="line">    RangeCheck(index);   </div><div class="line">  </div><div class="line">    E oldValue = (E) elementData[index];   </div><div class="line">    elementData[index] = element;   </div><div class="line">    <span class="keyword">return</span> oldValue;   </div><div class="line">}  </div><div class="line"></div><div class="line">   <span class="comment">// 将指定的元素插入此列表中的指定位置。   </span></div><div class="line"><span class="comment">// 如果当前位置有元素，则向右移动当前位于该位置的元素以及所有后续元素（将其索引加1）。   </span></div><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span>(<span class="keyword">int</span> index, E element) {   </div><div class="line">    <span class="keyword">if</span> (index &gt; size || index &lt; <span class="number">0</span>)   </div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"Index: "</span>+index+<span class="string">", Size: "</span>+size);   </div><div class="line">    <span class="comment">// 如果数组长度不足，将进行扩容。   </span></div><div class="line">    ensureCapacity(size+<span class="number">1</span>);  <span class="comment">// Increments modCount!!   </span></div><div class="line">    <span class="comment">// 将 elementData中从Index位置开始、长度为size-index的元素，   </span></div><div class="line">    <span class="comment">// 拷贝到从下标为index+1位置开始的新的elementData数组中。   </span></div><div class="line">    <span class="comment">// 即将当前位于该位置的元素以及所有后续元素右移一个位置。   </span></div><div class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>, size - index);   </div><div class="line">    elementData[index] = element;   </div><div class="line">    size++;   </div><div class="line">}  </div><div class="line"></div><div class="line"><span class="comment">// 按照指定collection的迭代器所返回的元素顺序，将该collection中的所有元素添加到此列表的尾部。   </span></div><div class="line"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span>(Collection&lt;? extends E&gt; c) {   </div><div class="line">    Object[] a = c.toArray();   </div><div class="line">    <span class="keyword">int</span> numNew = a.length;   </div><div class="line">    ensureCapacity(size + numNew);  <span class="comment">// Increments modCount   </span></div><div class="line">    System.arraycopy(a, <span class="number">0</span>, elementData, size, numNew);   </div><div class="line">    size += numNew;   </div><div class="line">    <span class="keyword">return</span> numNew != <span class="number">0</span>;   </div><div class="line">}  </div><div class="line"></div><div class="line"><span class="comment">// 从指定的位置开始，将指定collection中的所有元素插入到此列表中。   </span></div><div class="line"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span>(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c) {   </div><div class="line">    <span class="keyword">if</span> (index &gt; size || index &lt; <span class="number">0</span>)   </div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(   </div><div class="line">            <span class="string">"Index: "</span> + index + <span class="string">", Size: "</span> + size);   </div><div class="line">  </div><div class="line">    Object[] a = c.toArray();   </div><div class="line">    <span class="keyword">int</span> numNew = a.length;   </div><div class="line">    ensureCapacity(size + numNew);  <span class="comment">// Increments modCount   </span></div><div class="line">  </div><div class="line">    <span class="keyword">int</span> numMoved = size - index;   </div><div class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)   </div><div class="line">        System.arraycopy(elementData, index, elementData, index + numNew, numMoved);   </div><div class="line">  </div><div class="line">    System.arraycopy(a, <span class="number">0</span>, elementData, index, numNew);   </div><div class="line">    size += numNew;   </div><div class="line">    <span class="keyword">return</span> numNew != <span class="number">0</span>;   </div><div class="line">}</div></pre></td></tr></table></figure>

<hr>
<h3 id="4)_读取：">4) 读取：</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 返回此列表中指定位置上的元素。   </span></div><div class="line"><span class="keyword">public</span> E <span class="title">get</span>(<span class="keyword">int</span> index) {   </div><div class="line">    RangeCheck(index);   </div><div class="line">  </div><div class="line">    <span class="keyword">return</span> (E) elementData[index];   </div><div class="line">}</div></pre></td></tr></table></figure>

<hr>
<h3 id="5)_删除：">5) 删除：</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"> ArrayList提供了根据下标或者指定对象两种方式的删除功能。如下：</div><div class="line"></div><div class="line"><span class="comment">// 移除此列表中指定位置上的元素。   </span></div><div class="line"><span class="keyword">public</span> E <span class="title">remove</span>(<span class="keyword">int</span> index) {   </div><div class="line">    RangeCheck(index);   </div><div class="line">  </div><div class="line">    modCount++;   </div><div class="line">    E oldValue = (E) elementData[index];   </div><div class="line">  </div><div class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;   </div><div class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)   </div><div class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index, numMoved);   </div><div class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// Let gc do its work   </span></div><div class="line">  </div><div class="line">    <span class="keyword">return</span> oldValue;   </div><div class="line">}  </div><div class="line"></div><div class="line"><span class="comment">// 移除此列表中首次出现的指定元素（如果存在）。这是应为ArrayList中允许存放重复的元素。   </span></div><div class="line"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span>(Object o) {   </div><div class="line">    <span class="comment">// 由于ArrayList中允许存放null，因此下面通过两种情况来分别处理。   </span></div><div class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) {   </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)   </div><div class="line">            <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) {   </div><div class="line">                <span class="comment">// 类似remove(int index)，移除列表中指定位置上的元素。   </span></div><div class="line">                fastRemove(index);   </div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;   </div><div class="line">            }   </div><div class="line">} <span class="keyword">else</span> {   </div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)   </div><div class="line">        <span class="keyword">if</span> (o.equals(elementData[index])) {   </div><div class="line">            fastRemove(index);   </div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;   </div><div class="line">        }   </div><div class="line">    }   </div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;   </div><div class="line">}  </div><div class="line"></div><div class="line"><span class="comment">//注意：从数组中移除元素的操作，也会导致被移除的元素以后的所有元素的向左移动一个位置。</span></div></pre></td></tr></table></figure>

<hr>
<h3 id="6)_调整数组容量：">6) 调整数组容量：</h3>
<p>从上面介绍的向ArrayList中存储元素的代码中，我们看到，每当向数组中添加元素时，都要去检查添加后元素的个数是否<br>会超出当前数组的长度，如果超出，数组将会进行扩容，以满足添加数据的需求。数组扩容通过一个公开的方法<br>ensureCapacity(int minCapacity)来实现。在实际添加大量元素前，我也可以使用ensureCapacity来手动增加<br>ArrayList实例的容量，以减少递增式再分配的数量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span>(<span class="keyword">int</span> minCapacity) {   </div><div class="line">    modCount++;   </div><div class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;   </div><div class="line">    <span class="keyword">if</span> (minCapacity &gt; oldCapacity) {   </div><div class="line">        Object oldData[] = elementData;   </div><div class="line">        <span class="keyword">int</span> newCapacity = (oldCapacity * <span class="number">3</span>)/<span class="number">2</span> + <span class="number">1</span>;   </div><div class="line">            <span class="keyword">if</span> (newCapacity &lt; minCapacity)   </div><div class="line">                newCapacity = minCapacity;   </div><div class="line">      <span class="comment">// minCapacity is usually close to size, so this is a win:   </span></div><div class="line">      elementData = Arrays.copyOf(elementData, newCapacity);   </div><div class="line">    }   </div><div class="line">}</div></pre></td></tr></table></figure>

<p>  从上述代码中可以看出，数组进行扩容时，会将老数组中的元素重新拷贝一份到新的数组中，每次数组容量的增长大约是<br>  其原容量的1.5倍。这种操作的代价是很高的，因此在实际使用时，我们应该尽量避免数组容量的扩张。当我们可预知要<br>  保存的元素的多少时，要在构造ArrayList实例时，就指定其容量，以避免数组扩容的发生。或者根据实际需求，通过<br>  调用ensureCapacity方法来手动增加ArrayList实例的容量。<br>   ArrayList还给我们提供了将底层数组的容量调整为当前列表保存的实际元素的大小的功能。它可以通过trimToSize<br>   方法来实现。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trimToSize</span>() {   </div><div class="line">    modCount++;   </div><div class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;   </div><div class="line">    <span class="keyword">if</span> (size &lt; oldCapacity) {   </div><div class="line">        elementData = Arrays.copyOf(elementData, size);   </div><div class="line">    }   </div><div class="line">}</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html"><![CDATA[<h2 id="1-ArrayList概述">1.ArrayList概述</h2>
<pre><code>ArrayList是Lits可变数组的一种实现。实现了所有可选列表操作，并允许包括 <span class="literal">null</span> 在内的所有元素。除了实现 
</code></pre><p>List 接口外，此类还提供一些方法来操作内部用来存储列表的数组的大小。<br>    每个ArrayList实例都有一个容量，该容量是指用来存储列表元素的数组的大小。它总是至少等于列表的大小。随着向<br>ArrayList中不断添加元素，其容量也自动增长。自动增长会带来数据向新数组的重新拷贝，因此，如果可预知数据量的多<br>少，可在构造ArrayList时指定其容量。在添加大量元素前，应用程序也可以使用ensureCapacity操作来增加ArrayList<br>实例的容量，这可以减少递增式再分配的数量。<br>       注意，此实现不是同步的。如果多个线程同时访问一个ArrayList实例，而其中至少一个线程从结构上修改了列表，<br>那么它必须保持外部同步。</p>
]]></summary>
    
      <category term="转" scheme="http://zhushiqing.github.io/tags/%E8%BD%AC/"/>
    
      <category term="Java" scheme="http://zhushiqing.github.io/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[hashcode与equal]]></title>
    <link href="http://zhushiqing.github.io/2014/09/01/hashmap/"/>
    <id>http://zhushiqing.github.io/2014/09/01/hashmap/</id>
    <published>2014-09-01T14:36:56.000Z</published>
    <updated>2014-09-01T14:59:43.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Q：两个对象值相同_(x-equals(y)_==_true)_,但却可有不同的_hash_code_,这_句话对不对">Q：两个对象值相同 (x.equals(y) == true) ,但却可有不同的 hash code ,这 句话对不对</h2>
<p>答：不对，有相同的 hash code<br>这是java语言的定义：<br>1) 对象相等则hashCode一定相等；<br>2) hashCode相等对象未必相等</p>
<h2><a id="more"></a></h2>
<p>1.如果是基本变量，没有hashcode和equals方法，基本变量的比较方式就只有==；</p>
<p>2.如果是变量，由于在java中所有变量定义都是一个指向实际存储的一个句柄（你可以理解为c++中的指针），在这里==是比较句柄的地址（你可以理解为指针的存储地址），而不是句柄指向的实际内存中的内容，如果要比较实际内存中的内容，那就要用equals方法，但是！！！</p>
<p>如果是你自己定义的一个类，比较自定义类用equals和==是一样的，都是比较句柄地址，因为自定义的类是继承于object，而object中的equals就是用==来实现的，你可以看源码。</p>
<p>那为什么我们用的String等等类型equals是比较实际内容呢，是因为String等常用类已经重写了object中的equals方法，让equals来比较实际内容，你也可以看源码。</p>
<ol>
<li>hashcode</li>
</ol>
<p>在一般的应用中你不需要了解hashcode的用法，但当你用到hashmap，hashset等集合类时要注意下hashcode。</p>
<p>你想通过一个object的key来拿hashmap的value，hashmap的工作方法是，通过你传入的object的hashcode在内存中找地址，当找到这个地址后再通过equals方法来比较这个地址中的内容是否和你原来放进去的一样，一样就取出value。</p>
<p>所以这里要匹配2部分，hashcode和equals</p>
<p>但假如说你new一个object作为key去拿value是永远得不到结果的，因为每次new一个object，这个object的hashcode是永远不同的，所以我们要重写hashcode，你可以令你的hashcode是object中的一个恒量，这样永远可以通过你的object的hashcode来找到key的地址，然后你要重写你的equals方法，使内存中的内容也相等。。。</p>
<p>一般来讲，equals这个方法是给用户调用的，如果你想判断2个对象是否相等，你可以重写equals方法，然后在代码中调用，就可以判断他们是否相等了。简单来讲，equals方法主要是用来判断从表面上看或者从内容上看，2个对象是不是相等。举个例子，有个学生类，属性只有姓名和性别，那么我们可以认为只要姓名和性别相等，那么就说这2个对象是相等的。</p>
<p>hashcode方法一般用户不会去调用，比如在hashmap中，由于key是不可以重复的，他在判断key是不是重复的时候就判断了hashcode这个方法，而且也用到了equals方法。这里不可以重复是说equals和hashcode只要有一个不等就可以了！所以简单来讲，hashcode相当于是一个对象的编码，就好像文件中的md5，他和equals不同就在于他返回的是int型的，比较起来不直观。我们一般在覆盖equals的同时也要覆盖hashcode，让他们的逻辑一致。举个例子，还是刚刚的例子，如果姓名和性别相等就算2个对象相等的话，那么hashcode的方法也要返回姓名的hashcode值加上性别的hashcode值，这样从逻辑上，他们就一致了。</p>
<p>要从物理上判断2个对象是否相等，用==就可以了</p>
]]></content>
    <summary type="html"><![CDATA[<h2 id="Q：两个对象值相同_(x-equals(y)_==_true)_,但却可有不同的_hash_code_,这_句话对不对">Q：两个对象值相同 (x.equals(y) == true) ,但却可有不同的 hash code ,这 句话对不对</h2>
<p>答：不对，有相同的 hash code<br>这是java语言的定义：<br>1) 对象相等则hashCode一定相等；<br>2) hashCode相等对象未必相等</p>
<h2>]]></summary>
    
      <category term="转" scheme="http://zhushiqing.github.io/tags/%E8%BD%AC/"/>
    
      <category term="Java" scheme="http://zhushiqing.github.io/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[狼狈的一天]]></title>
    <link href="http://zhushiqing.github.io/2014/08/29/day140828/"/>
    <id>http://zhushiqing.github.io/2014/08/29/day140828/</id>
    <published>2014-08-29T00:59:50.000Z</published>
    <updated>2014-08-29T02:12:16.000Z</updated>
    <content type="html"><![CDATA[<h3 id="辞职，这是另一个起点。">辞职，这是另一个起点。</h3>
<p>最近心情摇摆了好久，终于下定了决心，我还年轻，我还有追逐梦想的权利。QA这工作确实不是我自己喜欢的。但是好喜欢<br>网易这个公司，还记得当年的梦幻西游，大唐，那一个个游戏，都是我所钟爱的，大网易是我好想进的一个公司，怀着少年<br>时代的梦想，在实习生招聘中，拒绝了SAP，恒天，老师公司的offer，我一无反顾的来到我梦想中的公司，他确实是那么的<br>真实，工作环境也是那么nice，还有那号称一日五顿的免费餐，这一切的一切确实好赞。</p>
<h2><a id="more"></a></h2>
<p>随着时间的流逝，那一切是趋于平淡，重复着那一个个自己兴趣不在的工作，对于自己来说，真的是煎熬，我学到了什么吗？<br>我一次又一次的反问自己，真的很无奈，我对于自己专业上的技术确实没有任何的长进，将来我还想靠这方面吃饭呢!可是我<br>有学到什么吗？= =实在是无奈到家了- -。对于我唯一不舍的，就是小伙伴吗，以及导师与红姐、Android小小组。与他<br>们之间的氛围还真的好nice，还记得那次卡丁车吗。真的好HI，好多小伙伴都是网易里面实习，对于他们也好不舍呢，犹豫<br>徘徊了好久！终于在最近下定了决心:我得走，这不是我想要的生活，也不是自己想要的兴趣所在!</p>
<p>于是，提前告别了小伙伴，还与之合影了，小伙伴大帝最棒，还有lyd，wn，zq都是好棒的呢！收拾一切回家。</p>
<p>28号这天折腾了一整天&amp;&amp;最后终于在下午完全收拾完，写完离职报告了。see u网易，假如校招研发还要我，我一定会回来的！<br>加油！</p>
<p>收拾完之后，走上回家的道路，挤上公交，来来往往的人们让我觉得好多好多感慨，一路颠簸，一路拥挤，一路堵车，来到<br>了市区，那浑浊的空气- -and 不巧的是= =我居然被中暑了，真心坑啊，一路直想吐，= =好可怜的我。</p>
<p>到了武林门那边居然又上来好多大妈，车里都没位置了- -，看着那些大妈好可怜，我强忍要吐的感觉，把座位让给了其中<br>一位，貌似那大妈开心的一笑，让我瞬间感觉我做的事情还有价值，忍了好久，终于下车了，然后找了一个最近的厕所吐了个疼快<br>= = 唉，可是出来就是瞬间天气大变，成了雷阵雨，让我成了落汤鸡！</p>
<hr>
<p>好吧，离职第一天。我很倒霉！</p>
]]></content>
    <summary type="html"><![CDATA[<h3 id="辞职，这是另一个起点。">辞职，这是另一个起点。</h3>
<p>最近心情摇摆了好久，终于下定了决心，我还年轻，我还有追逐梦想的权利。QA这工作确实不是我自己喜欢的。但是好喜欢<br>网易这个公司，还记得当年的梦幻西游，大唐，那一个个游戏，都是我所钟爱的，大网易是我好想进的一个公司，怀着少年<br>时代的梦想，在实习生招聘中，拒绝了SAP，恒天，老师公司的offer，我一无反顾的来到我梦想中的公司，他确实是那么的<br>真实，工作环境也是那么nice，还有那号称一日五顿的免费餐，这一切的一切确实好赞。</p>
<h2>]]></summary>
    
      <category term="狼狈" scheme="http://zhushiqing.github.io/tags/%E7%8B%BC%E7%8B%88/"/>
    
      <category term="blog" scheme="http://zhushiqing.github.io/categories/blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[数据库中的脏读，幻读，不可重复读]]></title>
    <link href="http://zhushiqing.github.io/2014/08/25/DataBase1/"/>
    <id>http://zhushiqing.github.io/2014/08/25/DataBase1/</id>
    <published>2014-08-25T11:31:11.000Z</published>
    <updated>2014-08-25T11:37:35.000Z</updated>
    <content type="html"><![CDATA[<h3 id="什么叫做数据库的脏读，不可重复读&amp;&amp;幻读呢！下面让我们来看看：">什么叫做数据库的脏读，不可重复读&amp;&amp;幻读呢！下面让我们来看看：</h3>
<a id="more"></a>

<hr>
<h3 id="1-脏读：">1.脏读：</h3>
<p>脏读就是指当一个事务正在访问数据，并且对数据进行了修改，<br>而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。</p>
<h3 id="2-不可重复读_：">2.不可重复读 ：</h3>
<p>是指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。<br>那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的的<br>数据可能是不一样的。这样就发生了在一个事务内两次读到的数据是不一样的，因此称为是不可重复读。<br>例如，一个编辑人员两次读取同一文档，但在两次读取之间，作者重写了该文档。当编辑人员第二次读<br>取文档时，文档已更改。原始读取不可重复。如果只有在作者全部完成编写后编辑人员才可以读取文档，<br>则可以避免该问题。</p>
<h3 id="3-幻读:">3.幻读:</h3>
<p>是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉<br>及到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。<br>那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样。<br>例如，一个编辑人员更改作者提交的文档，但当生产部门将其更改内容合并到该文档的主复本时，发现作<br>者已将未编辑的新材料添加到该文档中。如果在编辑人员和生产部门完成对原始文档的处理之前，任何人<br>都不能将新材料添加到文档中，则可以避免该问题。</p>
<h2 id="再来看看实际应用中：">再来看看实际应用中：</h2>
<p>基于元数据的Spring声明性事务:Isolation属性一共支持五种事务设置，具体介绍如下：</p>
<p>lDEFAULT使用数据库设置的 隔离级别(默认)<br>由DBA默认的设置来决定<br>隔离级别：.lREAD_UNCOMMITTED<br>会出现脏读、不可重复读、幻读(隔离级别最低，并发性能高)<br>lREAD_COMMITTED<br>会出现不可重复读、幻读问题（锁定正在读取的行）<br>lREPEATABLE_READ<br>会出幻读（锁定所读取的所有行）<br>lSERIALIZABLE<br>保证所有的情况不会发生（锁表）<br>不可重复读的重点是修改:同样的条件,<br>你读取过的数据,<br>再次读取出来发现值不一样了<br>幻读的重点在于新增或者删除同样的条件,第1次和第2次读出来的记录数不一样</p>
]]></content>
    <summary type="html"><![CDATA[<h3 id="什么叫做数据库的脏读，不可重复读&amp;&amp;幻读呢！下面让我们来看看：">什么叫做数据库的脏读，不可重复读&amp;&amp;幻读呢！下面让我们来看看：</h3>
]]></summary>
    
      <category term="数据库" scheme="http://zhushiqing.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="DataBase" scheme="http://zhushiqing.github.io/categories/DataBase/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[那些笑cry的面向对象总结]]></title>
    <link href="http://zhushiqing.github.io/2014/08/24/LittleThing/"/>
    <id>http://zhushiqing.github.io/2014/08/24/LittleThing/</id>
    <published>2014-08-24T02:20:29.000Z</published>
    <updated>2014-08-24T02:27:13.000Z</updated>
    <content type="html"><![CDATA[<p>看到别人写的总结，不忍直视，特意一转！<br><a id="more"></a></p>
<p>小诗一首：</p>
<blockquote>
<p>我能把整个世界都抽象成对象​  </p>
<p>但是没办法把你变成我的对象​ </p>
<p>想让你成为私有常量，外部函数无法访问你    </p>
<p>又想让你变成全局常量，在整个生命周期随时随地都可以调用你​</p>
<p>因为世界上没有这样的常量​ </p>
<p>所以我无法定义你​ </p>
<p>我可以重载甚至覆盖任何一种方法​</p>
<p>但是我却不能重载对你的思念​</p>
<p>也许命中注定了 你在我的世界里永远的烙上了静态的属性</p>
<p>而我不慎调用了爱你这个方法</p>
<p>当我义无返顾的把自己作为参数传进这个方法时</p>
<p>我才发现“爱你”方法里面执行是一个死循环</p>
<p>她不停的返回对你的思念存入我心里的堆栈</p>
<p>在这无尽的无穷无尽循环中​</p>
<p>我的内存资源已经快消耗殆尽</p>
<p>我却依然不停的向系统申请空间换取我对你的想念</p>
<p>终于我受不了爱你的煎熬</p>
<p>调用了“表白”这个Public方法​</p>
<p>将字符串 “如果你爱你，我将用尽一生去爱你，你爱我吗？” 传递给你​</p>
<p>我却捕获一个异常－－－内存溢出,我爱的人不爱我</p>
<p>为了解决这个异常​</p>
<p>我偷偷修改”表白”的方法​</p>
<p>加上了异常处理finally块​</p>
<p>并且将返回值设为真</p>
<p>心想这样万无一失了吧​</p>
<p>鼓起勇气再一次调用“表白”​</p>
<p>我却依然捕获到同样的异常​</p>
<p>仔细调试代码原来在方法中有一段这样的代码​</p>
<p>“如果没房没车，则执行System.exit()”​</p>
</blockquote>
]]></content>
    <summary type="html"><![CDATA[<p>看到别人写的总结，不忍直视，特意一转！<br>]]></summary>
    
      <category term="转" scheme="http://zhushiqing.github.io/tags/%E8%BD%AC/"/>
    
      <category term="blog" scheme="http://zhushiqing.github.io/categories/blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java虚拟机中ClassLoader的机制分析]]></title>
    <link href="http://zhushiqing.github.io/2014/08/18/ClassLoader/"/>
    <id>http://zhushiqing.github.io/2014/08/18/ClassLoader/</id>
    <published>2014-08-18T05:39:51.000Z</published>
    <updated>2014-08-19T06:42:46.000Z</updated>
    <content type="html"><![CDATA[<h2 id="首先我们得明白什么是类加载器（ClassLoader）：">首先我们得明白什么是类加载器（ClassLoader）：</h2>
<p><em>A</em>【类加载的作用】：java中的类加载器就是把java字节码（class文件）从硬盘中加载到内存中,然后做一些处理，这就是类加载器。</p>
<p>一般来说，类加载器本身是一个java类，但是BootStrap加载器是C++写成的。是所有加载器的根。<br><a id="more"></a><br>默认情况下，java提供了三个默认加载器：</p>
<blockquote>
<ul>
<li>BootStrap：只从classpath指定的目录或者jar包下面加载类</li>
<li>ExtClassLoader：加载JRE/lib/ext/*.jar</li>
<li>AppClassLoader：专门加载JRE/lib/rt.jar</li>
</ul>
</blockquote>
<p>先看一段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> zju.zsq.day01;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTest</span> </span>{</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {</div><div class="line">		</div><div class="line">		System.out.println(</div><div class="line">				ClassLoaderTest.class.getClassLoader()</div><div class="line">				.getClass().getName());</div><div class="line">		System.out.println(</div><div class="line">				System.class.getClassLoader()</div><div class="line">				);</div><div class="line">		</div><div class="line">		ClassLoader loader = ClassLoaderTest.class.getClassLoader();</div><div class="line">		<span class="comment">//看下树状结构,如果为null就代表找不到java的class文件，等于找到了bootstrap（C++实现的加载）</span></div><div class="line">		<span class="keyword">while</span>(loader != <span class="keyword">null</span>){</div><div class="line">			System.out.println(loader.getClass().getName());</div><div class="line">			loader = loader.getParent();</div><div class="line">		}</div><div class="line">		System.out.println(loader);</div><div class="line">		<span class="javadoc">/**</span></div><div class="line">		 * AppClassLoader:只从classpath指定的目录或者jar包下面加载类</div><div class="line">		 * ExtClassLoader：JRE/lib/ext/*.jar</div><div class="line">		 * BootStrap：专门加载JRE/lib/rt.jar</div><div class="line">		 */</div><div class="line">		System.out.println(<span class="keyword">new</span> ClassLoaderAttachment().toString());</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">sun.misc.Launcher$AppClassLoader</div><div class="line"><span class="keyword">null</span></div><div class="line">sun.misc.Launcher$AppClassLoader</div><div class="line">sun.misc.Launcher$ExtClassLoader</div><div class="line"><span class="keyword">null</span></div></pre></td></tr></table></figure>

<p>从代码里面我们可以看到，从上到下加载器是成树状的（<code>其中null为BootStrap，因为上诉代码得到的是classname，但是C++没有生产字节码，所以为null</code>），再让我们看看下图：<br><img src="/image/classloader.png" alt=""></p>
<h2 id="java虚拟机加载一个类的时候，到底派出哪个类加载器去加载呢？">java虚拟机加载一个类的时候，到底派出哪个类加载器去加载呢？</h2>
<p><em>A</em> ：一般来说是当前线程的类加载器去加载线程中的第一个类，Thread.currentThread().getContextClassLoader(),当然从上面的代码我可以知道加载ClassLoaderTest这个类是AppClassLoader加载器。具体来说，ClassLoaderTest用这个AppClassLoader加载器来加载，但是它不是立即就加载的 。过程如下：</p>
<blockquote>
<ul>
<li>1.ClassLoaderTest先找到他的加载器AppClassLoader</li>
<li>2.AppClassLoader就委托到父加载器ExtClassLoader加载</li>
<li>3.ExtClassLoader开始加载，找不到加载类，就开始委托给它的子加载器ExtClassLoader</li>
<li>4.ExtClassLoader开始加载，找不到加载类，就开始委托给它的子加载器AppClassLoader</li>
<li>5.AppClassLoader开始加载，找到加载，加载完毕。</li>
</ul>
</blockquote>
<p>这是一个<strong>委托机制</strong>，一般来说，先是从现在类的加载器，一层层委托到最顶层的加载器，然后顶层的加载器，开始加载，找不到加载类，就委托给下一层，如果在到当前类的加载器之前加载完毕，就结束。如果直到当前类还加载不了，就抛ClassNotFoundException。</p>
<p>这个委托机制的优点是：方便集权管理，比如说只有不会生成多份字节码。</p>
<p>在这里突然就想到了一份经典的面试题，能否自己重写Java.lang.system这个类<br>答案是当然可以，但是一般情况下写了也得于白写，当委托到最顶上的那个加载器就直接被加载了。除非自己写一个加载器，然后还要<strong>抛开委托机制</strong>。</p>
<p><em>好了，今天算是把加载器粗略的了解下，与诸君共勉！加油！</em></p>
<hr>
]]></content>
    <summary type="html"><![CDATA[<h2 id="首先我们得明白什么是类加载器（ClassLoader）：">首先我们得明白什么是类加载器（ClassLoader）：</h2>
<p><em>A</em>【类加载的作用】：java中的类加载器就是把java字节码（class文件）从硬盘中加载到内存中,然后做一些处理，这就是类加载器。</p>
<p>一般来说，类加载器本身是一个java类，但是BootStrap加载器是C++写成的。是所有加载器的根。<br>]]></summary>
    
      <category term="Java" scheme="http://zhushiqing.github.io/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Proxy机制（java动态代理机制）]]></title>
    <link href="http://zhushiqing.github.io/2014/08/13/Proxy/"/>
    <id>http://zhushiqing.github.io/2014/08/13/Proxy/</id>
    <published>2014-08-13T11:06:01.000Z</published>
    <updated>2014-08-15T00:33:52.000Z</updated>
    <content type="html"><![CDATA[<p>什么是动态代理？</p>
<h2 id="java动态代理机制">java动态代理机制</h2>
<ul>
<li>Q1：什么叫做动态代理机制？</li>
<li>Q2：动态代理机制有什么好处？</li>
<li>Q3：什么地方用到动态代理？</li>
</ul>
<hr>
<a id="more"></a>

<h3 id="动态代理的源码在java-lang-reflect这个包里，应该是Proxy类。里面有提供两个静态方法：">动态代理的源码在java.lang.reflect这个包里，应该是Proxy类。里面有提供两个静态方法：</h3>
<hr>
<p><strong>1</strong>.Class&lt;?&gt; getProxyClass(ClassLoader loader, Class&lt;?&gt;[] interface)</p>
<p>用来产生代理类，参数要提供interface数组，它会生成这些interface的“虚拟实现”，<br>用来冒充真实的对象。</p>
<p><strong>2</strong>.Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) </p>
<p>产生代理对象，多了InvocationHandler参数(只是InvocationHandler接口的实现类)，<br>它与代理对象关联，当请求分发到代理对象后，会<strong><em>自动执行h.invoke(…)方法</em></strong>，所以在<br>invoke方法中，我们可以做很多事情。</p>
<hr>
<p><strong><em>“动态”</em></strong>是针对静态编码而言的，可以是编译器、类装载器和运行期。</p>
<p>引一个大大的例子来说下自己的理解：比如有有一个接口A，里面有方法sayHello(),print()方法。然后一个B类（AIml类）来实现<br>具体实现A接口，然后再写一个代理类，伪装成B类，代理类里面通过动态的实现B类的方法（其实就是通过反射实现的B类方法），<br>然后外面的请求发过来之后，都是通过代理类来处理，方便集中处理一系列的方便的集成权限控制，异常处理，事务控制，<br>性能统计等等（这里感谢 <em>方老师</em> 对我指点）</p>
<p>然后下面是一个网上大大对动态代理的画的图，大家参考一下很明了的关系图。</p>
<p><img src="http://langyu.iteye.com/upload/picture/pic/38786/bfe44656-08f7-3d4d-b9d8-0de6ad00c7de.jpg" alt=""></p>
<p>A接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">A</span> </span>{</div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span>(String to);</div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span>(String p);</div><div class="line">}</div></pre></td></tr></table></figure>

<p>B类（实现A接口）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AImpl</span> <span class="keyword">implements</span> <span class="title">A</span></span>{</div><div class="line"></div><div class="line">    <span class="annotation">@Override</span></div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span>(String to) {</div><div class="line">		System.out.println(<span class="string">"Hello:"</span>+to);</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="annotation">@Override</span></div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span>(String p) {</div><div class="line">		System.out.println(<span class="string">"print:"</span>+p);</div><div class="line">	}</div><div class="line"></div><div class="line">}</div></pre></td></tr></table></figure>

<p>C类（代理类，伪装成B类）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</div><div class="line"><span class="keyword">import</span> java.lang.reflect.Method;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Handler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span></span>{</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Object obj;</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="title">Handler</span>(Object obj){</div><div class="line">		<span class="keyword">this</span>.obj = obj;</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="annotation">@Override</span></div><div class="line">	<span class="keyword">public</span> Object <span class="title">invoke</span>(Object proxy, Method method, Object[] args)</div><div class="line">			<span class="keyword">throws</span> Throwable {</div><div class="line">		</div><div class="line">		doBefore();</div><div class="line">		Object result = method.invoke(obj, args);</div><div class="line">		doAfter();</div><div class="line">		</div><div class="line">		<span class="keyword">return</span> result;</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAfter</span>() {</div><div class="line">		System.out.println(<span class="string">"after..."</span>);</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doBefore</span>() {</div><div class="line">		System.out.println(<span class="string">"before..."</span>);</div><div class="line">	}</div><div class="line"></div><div class="line">}</div></pre></td></tr></table></figure>

<p>测试类：D类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyTester</span> </span>{</div><div class="line"></div><div class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {</div><div class="line">	        A impl = <span class="keyword">new</span> AImpl();</div><div class="line">	        Handler handler = <span class="keyword">new</span> Handler(impl);</div><div class="line">	        <span class="comment">//这里把handler与impl新生成的代理类相关联</span></div><div class="line">	        A hello = (A) Proxy.newProxyInstance(impl.getClass().getClassLoader(), </div><div class="line">			</div><div class="line">			impl.getClass().getInterfaces(), handler);</div><div class="line">	        </div><div class="line">	        <span class="comment">//这里无论访问哪个方法，都是会把请求转发到handler.invoke</span></div><div class="line">	        hello.print(<span class="string">"All the test"</span>);</div><div class="line">	        hello.sayHello(<span class="string">"SunnyZhu"</span>);</div><div class="line">	    }</div><div class="line"></div><div class="line">}</div></pre></td></tr></table></figure>

<p>测试结果如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">before...</div><div class="line">print:All the test</div><div class="line">after...</div><div class="line">before...</div><div class="line">Hello:zhushiqing</div><div class="line">after...</div></pre></td></tr></table></figure>

<p>自此代码就实现了，在hello（A类）调用的动态方法都是集中交给代理类来处理了。方便在代理类集中处理一些事情，before 干点啥，after干点啥。</p>
<hr>
<p>最后回答下三个Questions</p>
<p>A1:一种用于转发请求，进行特殊处理的机制，这里的动态是针对静态编码而言的，可以是编译器、类装载器和运行期。</p>
<p>A2:方便的集成权限控制，异常处理，事务控制，性能统计等等</p>
<p>A3:很多地方，web层的controller，biz层的service，都会使用动态代理，目的在于实现aop，</p>
<hr>
<p><em>学习了java动态代理，与诸君共勉！</em></p>
]]></content>
    <summary type="html"><![CDATA[<p>什么是动态代理？</p>
<h2 id="java动态代理机制">java动态代理机制</h2>
<ul>
<li>Q1：什么叫做动态代理机制？</li>
<li>Q2：动态代理机制有什么好处？</li>
<li>Q3：什么地方用到动态代理？</li>
</ul>
<hr>
]]></summary>
    
      <category term="Java" scheme="http://zhushiqing.github.io/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java中Hashmap存不下那些数据怎么办（有一堆数据）？]]></title>
    <link href="http://zhushiqing.github.io/2014/08/13/hashmapOutOfmemory/"/>
    <id>http://zhushiqing.github.io/2014/08/13/hashmapOutOfmemory/</id>
    <published>2014-08-13T06:07:55.000Z</published>
    <updated>2014-08-15T06:50:44.000Z</updated>
    <content type="html"><![CDATA[<h1 id="突然想起前几天有人问的关于HashMap一个问题">突然想起前几天有人问的关于HashMap一个问题</h1>
<hr>
<p>假如hashmap中存入了大量的数据，存不下了怎么办呢！？好吧，当时我就惊呆了。hashmap还有内存溢出的情况简直是不能忍！次奥，但是左思右想总是想不出答案来。好吧，我承认又得补脑了<br>0_0。回来各种查资料。<br><a id="more"></a></p>
<p>整个分析流程如下：</p>
<blockquote>
<ul>
<li>Q1：什么是hashmap？</li>
<li>Q2：为什么会有hashmap存储不下数据的情况产生？</li>
<li>Q3：如何解决此情况？</li>
</ul>
</blockquote>
<hr>
<h2 id="什么是_HashMap?">什么是 HashMap?</h2>
<p>首先让我们来了解下数组和链表：数组在寻址能力比较强大、但是插入&amp;&amp;删除能力较弱；链表在寻址能力较弱，但是插入删除能力比较强。那么有没有一种寻址容易，插入删除又容易的数据结构！答案就是有的！Hash表欢迎您！而HashMap又是Hash表的一种，线程不安全，但是性能较Hashtable高一些。所以HashMap与HashTable之间常用HashMap.</p>
<h2 id="为什么会有HashMap存储不下数据的情况产生？">为什么会有HashMap存储不下数据的情况产生？</h2>
<p>一般情况下不会出现这样的情况，除非这个数据真的非常多&amp;&amp;你做Key对象没有实现自己的HashCode算法，导致存储了好多冗余的数据。</p>
<h2 id="怎么解决？">怎么解决？</h2>
<p>一般情况下应该对你做key的对象进行hashcode方法、equals方法的重写，然后定期清理不使用的强映射、或者使用WeekHashMap：会让GC定期清理不使用的数据，一般就不会出现这样的情况了。<br>当然有更狠的一招- -把JVM内存+++(这个不推荐，知道即可)</p>
<p><em>今天又学习了一点知识，与诸君共勉！</em></p>
]]></content>
    <summary type="html"><![CDATA[<h1 id="突然想起前几天有人问的关于HashMap一个问题">突然想起前几天有人问的关于HashMap一个问题</h1>
<hr>
<p>假如hashmap中存入了大量的数据，存不下了怎么办呢！？好吧，当时我就惊呆了。hashmap还有内存溢出的情况简直是不能忍！次奥，但是左思右想总是想不出答案来。好吧，我承认又得补脑了<br>0_0。回来各种查资料。<br>]]></summary>
    
      <category term="Java" scheme="http://zhushiqing.github.io/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[关于http请求的全过程]]></title>
    <link href="http://zhushiqing.github.io/2014/08/12/thinkingOfHttp/"/>
    <id>http://zhushiqing.github.io/2014/08/12/thinkingOfHttp/</id>
    <published>2014-08-12T06:34:11.000Z</published>
    <updated>2014-08-13T07:51:10.000Z</updated>
    <content type="html"><![CDATA[<h2 id="这是一只菜鸟关于http请求全过程的一个了解">这是一只菜鸟关于http请求全过程的一个了解</h2>
<hr>
<p>有些时候真的是不问不知道，发现自己真的都是筛子，所以呢！被人问了个http请求从开始到最后都做了什么<br>我居然不知道，实在是惭愧，说实话，自己也确实没去了解过这一块的内容。<br>不过既然别人问了，那么就得好好去查漏补缺。<a id="more"></a></p>
<h3 id="The_first：首先你在浏览器地址敲了一段网址">The first：首先你在浏览器地址敲了一段网址</h3>
<hr>
<p>首先我们敲了一段地址比如说：www.baidu.com 首先是将此变成url，如果没有加端口号的话，就使用默认的端口号，然后经过DNS服务器解析成一段IP。如果DNS服务器没有解析此IP，那就将发送给上一级的DNS服务器，直到返回一个IP，这样。我们就可以开始建立socket链接了。</p>
<hr>
<h3 id="The_second:_socket请求建立之后">The second:  socket请求建立之后</h3>
<hr>
<p>开始向服务器发送get/post请求</p>
<hr>
<h3 id="The_third：服务器开始处理请求">The third：服务器开始处理请求</h3>
<hr>
<p>比如说filter开始init，然后dofilter，然后doDestory，servlet开始工作诸如此类。然后开始给客户端发一个反馈</p>
<hr>
<h3 id="The_fourth:关闭链接">The fourth:关闭链接</h3>
<hr>
<p>跟所有处理一样，比如数据库的处理等等，弄完之后都可以做一个关闭链接处理，这样就可以让其他人访问这个服务器资源了。</p>
<hr>
<p>总结完毕。今天又多学了点了。</p>
]]></content>
    <summary type="html"><![CDATA[<h2 id="这是一只菜鸟关于http请求全过程的一个了解">这是一只菜鸟关于http请求全过程的一个了解</h2>
<hr>
<p>有些时候真的是不问不知道，发现自己真的都是筛子，所以呢！被人问了个http请求从开始到最后都做了什么<br>我居然不知道，实在是惭愧，说实话，自己也确实没去了解过这一块的内容。<br>不过既然别人问了，那么就得好好去查漏补缺。]]></summary>
    
      <category term="blog" scheme="http://zhushiqing.github.io/categories/blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[python群发邮件]]></title>
    <link href="http://zhushiqing.github.io/2014/08/07/python1/"/>
    <id>http://zhushiqing.github.io/2014/08/07/python1/</id>
    <published>2014-08-07T00:12:34.000Z</published>
    <updated>2014-08-12T01:45:08.000Z</updated>
    <content type="html"><![CDATA[<p>最近对工作上的各种重复事情感到各种厌倦！于是乎，总在琢磨着能不能偷懒！（偷懒是代码的源动力！）<br>最好的事情就是把每天重复的工作给抽取出来，把改变不大的事情写成一个脚本！<br>于是<a id="more"></a></p>
<p>我先拿每天必发的每日工作邮件做了尝试，毕竟每天的邮件内容改动不大！</p>
<h3 id="以下是我的python发邮件的代码，当然我因为内容少，直接在标签里面写了我的邮件正文，如果你想做自己的改进也可以自己写一张html页面">以下是我的python发邮件的代码，当然我因为内容少，直接在<pre>标签里面写了我的邮件正文，如果你想做自己的改进也可以自己写一张html页面</pre></h3>
<p>然后让脚本把内容读进邮件内容里面。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#这里以163的邮箱账号举例，不支持抄送，只支持群发！</span></div><div class="line"><span class="keyword">import</span> smtplib  </div><div class="line"><span class="keyword">from</span> email.mime.text <span class="keyword">import</span> MIMEText  </div><div class="line"><span class="comment">#mailto_list 收件人列表，这里是python里面的一个容器，每个联系人之间用“,”分开</span></div><div class="line">mailto_list=[<span class="string">"xxxx@163.com"</span>,<span class="string">"xxx@163.com"</span>] </div><div class="line">mail_host=<span class="string">"stmp.163.com"</span>  <span class="comment">#设置服务器</span></div><div class="line">mail_user=<span class="string">"xxxx"</span>    <span class="comment">#用户名</span></div><div class="line">mail_pass=<span class="string">"xxxx"</span>    <span class="comment">#用户密码</span></div><div class="line">mail_postfix=<span class="string">"163.com"</span>  <span class="comment">#发件箱的后缀</span></div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">send_mail</span><span class="params">(to_list,sub,content)</span>:</span>  <span class="comment">#to_list：收件人；sub：主题；content：邮件内容</span></div><div class="line">    me=<span class="string">"XXX"</span>+<span class="string">"&lt;"</span>+mail_user+<span class="string">"@"</span>+mail_postfix+<span class="string">"&gt;"</span>   <span class="comment">#这里的“XXX”可以任意设置 比如您好，收到信后，将按照提示 就相当于一个昵称</span></div><div class="line">    msg = MIMEText(content,_subtype=<span class="string">'html'</span>,_charset=<span class="string">'gb2312'</span>)    <span class="comment">#创建一个实例，这里设置为html格式邮件</span></div><div class="line">    msg[<span class="string">'Subject'</span>] = sub    <span class="comment">#设置主题</span></div><div class="line">    msg[<span class="string">'From'</span>] = me  </div><div class="line">    msg[<span class="string">'To'</span>] = <span class="string">";"</span>.join(to_list)  </div><div class="line">    <span class="keyword">try</span>:  </div><div class="line">        s = smtplib.SMTP()  </div><div class="line">        s.connect(mail_host)  <span class="comment">#连接smtp服务器</span></div><div class="line">        s.login(mail_user,mail_pass)  <span class="comment">#登陆服务器</span></div><div class="line">        s.sendmail(me, to_list, msg.as_string())  <span class="comment">#发送邮件</span></div><div class="line">        s.close()  </div><div class="line">        <span class="keyword">return</span> <span class="keyword">True</span>  </div><div class="line">    <span class="keyword">except</span> Exception, e:  </div><div class="line">        <span class="keyword">print</span> str(e)  </div><div class="line">        <span class="keyword">return</span> <span class="keyword">False</span>  </div><div class="line"></div><div class="line"><span class="comment">#send_mail里面填写的是用户名列表，邮件的标题，还有邮件内容（content）三者用,分隔开,&lt;br/&gt;为html标签里面的换行</span></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:  </div><div class="line">    <span class="keyword">if</span> send_mail(mailto_list,<span class="string">"这里是邮件标题！"</span>,</div><div class="line">                 <span class="string">"&lt;pre&gt;Hi All:&lt;br/&gt;\</span></div><div class="line">                 今天的天气不错哦&lt;br/&gt;\</div><div class="line">                 所以要不要出去玩？ &lt;br/&gt;快来跟我说下吗！&lt;br/&gt;&lt;br/&gt;\</div><div class="line">                &lt;/pre&gt;"):  </div><div class="line">        <span class="keyword">print</span> <span class="string">"发送成功"</span>  </div><div class="line">    <span class="keyword">else</span>:  </div><div class="line">        <span class="keyword">print</span> <span class="string">"发送失败"</span></div></pre></td></tr></table></figure>

]]></content>
    <summary type="html"><![CDATA[<p>最近对工作上的各种重复事情感到各种厌倦！于是乎，总在琢磨着能不能偷懒！（偷懒是代码的源动力！）<br>最好的事情就是把每天重复的工作给抽取出来，把改变不大的事情写成一个脚本！<br>于是]]></summary>
    
      <category term="python" scheme="http://zhushiqing.github.io/categories/python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Some plan I will do]]></title>
    <link href="http://zhushiqing.github.io/2014/08/01/plan/"/>
    <id>http://zhushiqing.github.io/2014/08/01/plan/</id>
    <published>2014-08-01T01:48:33.000Z</published>
    <updated>2014-08-12T02:54:56.000Z</updated>
    <content type="html"><![CDATA[<p>怎么说呢，有些时候，总是觉得这么漫无目的的做事情很对不起自己，没有效率<br>没有成果，没有成功的喜悦。总是有些得过且过的想法。这校招还没开始，我已<br>经这么堕落了，怎么可以呢？！<a id="more"></a></p>
<h3 id="1-English">1.English</h3>
<hr>
<p>首先自己的六级早八百年前过期了！所以应该应该在12月份重新考一个六级！<br>这么一说，那么单词应该背的，作文都应该写的，阅读应该做的！对于程序猿来说English是必备的技能之一！所以每天来50个单词吧！<br><a href="http://www.baicizhan.com/login" target="_blank" rel="external">百词斩</a>:背单词专用，还有iphone版本，点32个赞</p>
<h2 id="四六级测试:网易云课堂继续点32个赞！"><a href="http://study.163.com/find.htm#/find/search?p=%E5%85%AD%E7%BA%A7" target="_blank" rel="external">四六级测试</a>:网易云课堂继续点32个赞！</h2>
<h3 id="2-python">2.python</h3>
<hr>
<p>python这个是好东西啊，继承了各种库，能干好多事情！各种自动化，懒人专用，每天<br>花费很少的时间就能干好多任务.所以,自动化吗,必须 每天一小时学习！</p>
<h2 id="教程在这边：雪峰大大的python写的深入浅出，非常适合初学者学习，他的github教程也相当不错。"><a href="http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000" target="_blank" rel="external">教程在这边</a>：雪峰大大的python写的深入浅出，非常适合初学者学习，他的github教程也相当不错。</h2>
<h3 id="3-java设计模式">3.java设计模式</h3>
<hr>
<p>设计模式这种东西，我觉得只要掌握最常用的即可，比如说单例模式（饿汉跟懒汉模式，其他Enum,双重校验锁之类的暂时不用考虑），比如工厂模式（极大的解耦合）：静态工厂模式、工厂方法模式、抽象工厂模式。观察者模式、适配者模式等等几个常见的即可。</p>
<h2 id="每天花费30分钟复习。">每天花费30分钟复习。</h2>
<h3 id="4-java数据结构与算法">4.java数据结构与算法</h3>
<hr>
<p>常用的算法神马的，比如最常见的内排，简单的查找，以及算法优化。</p>
<h2 id="每天花费20分钟复习。">每天花费20分钟复习。</h2>
<h3 id="5-数据库：mysql">5.数据库：mysql</h3>
<hr>
<p>mysql也是那种不常用，但是不用之后就会忘记了！</p>
<h2 id="所以要多花时间来复习！每天30分钟。">所以要多花时间来复习！每天30分钟。</h2>
<h2 id="最后说一句：温故而知新，可以为师矣！">最后说一句：温故而知新，可以为师矣！</h2>
]]></content>
    <summary type="html"><![CDATA[<p>怎么说呢，有些时候，总是觉得这么漫无目的的做事情很对不起自己，没有效率<br>没有成果，没有成功的喜悦。总是有些得过且过的想法。这校招还没开始，我已<br>经这么堕落了，怎么可以呢？！]]></summary>
    
      <category term="blog" scheme="http://zhushiqing.github.io/categories/blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[某互联公司音乐Android端问题总结]]></title>
    <link href="http://zhushiqing.github.io/2014/07/31/my-new-post/"/>
    <id>http://zhushiqing.github.io/2014/07/31/my-new-post/</id>
    <published>2014-07-31T07:32:34.000Z</published>
    <updated>2014-08-04T07:32:50.000Z</updated>
    <content type="html"><![CDATA[<p>先小小的自我介绍下，以前从来没有在互联网公司实习。从14.04.09号开始在XXX音乐Android端QA实习，至今也快实习了4个月整了，现在听着同学们说做QA真的学不到什么东西，但是我觉得呢，做什么都能学到东西，关键是一个态度问题。当然，这个学习也要做一个定期的review，不然真的会造成一个没有学到任何东西的情况，下面我就给自己遇到的一些奇葩以及常规的问题做一些自己的总结:<a id="more"></a></p>
<p>下面是反馈系统当中最常遇到的一些问题（参考师傅的问题归类） ：</p>
<blockquote>
<ul>
<li>本地类问题：下载目录转移、扫描歌曲、词图保存失败、本地播放各种错误</li>
<li>播放类问题：在线无法播放、播放一小段跳转、播放终止</li>
<li>小部件问题：通知栏问题、小部件问题</li>
<li>稳定性问题：闪退</li>
<li>免流量问题：无法使用流量观看MV</li>
<li>下载类问题：下载失败</li>
<li>耳机类问题：线控失效、线控出错、蓝牙无效</li>
<li>UI常规问题：页面出错、页面不适配</li>
<li>持久化问题：主题、设置里面的</li>
<li>词图类问题：歌词出错、歌词不同步</li>
<li>分享类问题：分享到微信、微博无法播放或者观看MV、歌曲</li>
<li>其他常见问题：待添加</li>
<li>电台类问题：待添加</li>
</ul>
</blockquote>
<p>好吧，<code>Android</code>总是会出现各种奇葩的问题，各种rom，各种碎片化，这也是开源的弊端，毕竟大家都能做的话，各自都定制了各自的规则，然后一个应用要跑在所有的rom，所有的机子下面，你会发现好神奇的事情发生了！<strong>for example:</strong>一个歌曲信息！会被其他浮层遮住，永远用着ihpone的高富帅&amp;白富美是幸运的，他们永远不会体会那种，一个个应用在各种不同的手机上的奇葩姿态，这时候兼容性的重要就体现出来了！我们的口号就是：为大众服务！！！！！！！！！</p>
<h2 id="本地类问题">本地类问题</h2>
<p>每个厂商的SD卡不一样，很多都是各自定制的，这就导致一些很奇（zheng）怪（chang）的问题出现！比如说读写的权限问题，很多地方会给你限制住。然后：XXX用户就来反应了—-我的下载目录怎么改不了（很有可能是SD卡的权限没有）、我的歌词分享图片怎么保存不了（得去问问用户其他第三方应用能不能保存图片到手机默认相册）、本地不能播放（这个有可能是文件格式不支持）、本地扫描失败（可能是扫描本地的文件权限问题，导致歌曲没被扫描出来，特别是第三方应用的内置文件）and…..</p>
<h2 id="播放类问题">播放类问题</h2>
<p>这个播放特指的是在线播放，播放的问题也是比较奇葩，这个跟手机硬件也有关系，就拿一些奇葩的手机来说——W20一只超大的新华的手机，如果当歌曲缓冲没有完毕的时候，他是不会播放歌曲的！这个完全违背了歌曲播放的规律，还有就是在线无法播放！有些用户很奇葩会反馈一些弱智的问题，就比如比较有槽点的：为什么我的手机无法播放！——其实是他自己设置了近WIFI下播放，但是呢！他在用流量的时候播放！这不是明摆着让我来吐槽的吗= =。还有播放一小段跳转，播放终止。前者有可能是网络问题，不过具体还得查查bi，后者就有可能是网络问题了。或者说有些用户干脆自己设置了定时停止。</p>
<h2 id="小部件问题：">小部件问题：</h2>
<p>有些时候，由于没有采用自己定制的锁屏，程序调用的是原生的锁屏，所以会导致一些比较个性化的ROM无法在锁屏切歌！比如说最常见的小米手机，不过已经在考虑做自己的锁屏。还有一些小部件出了小问题，比如说小部件不能添加喜欢啊，诸如此类的。这些就得具体问题具体分析。</p>
<h2 id="稳定性问题:">稳定性问题:</h2>
<p>这一版本的稳定性问题最为突出，我个人感觉应该是垃圾回收算法没有写好，导致应用占的内存过大，导致内存不足所以被退了。当然导致闪退的原因有各式各样的：for example,第三方系统管理软件leb，360之类的，这些会自动清理后台，电量管理软件。还有就是程序bug导致的闪退，本地扫描到特殊文件导致的闪退。具体的问题都要看具体的log来确定问题。</p>
<h2 id="免流量的问题">免流量的问题</h2>
<p>免流量的问题大多有申请了免流量，却没有被开通，这个需要查下，不过具体我也不太清楚，还有一些就是开通了免流量，但是用不了，居我所知大概会有几种，其中之一就是用户现在的手机卡不是开通免流量的卡，还有就是手机卡网络接入点的问题，net与wap换一下即可。</p>
<h2 id="下载类问题：">下载类问题：</h2>
<p>下载失败有很多可能，查bi可以知道，一般来说会有写入权限没有的错误，用户手机的缘故，还有就是网络环境的问题。</p>
<h2 id="耳机类问题">耳机类问题</h2>
<p>耳机类的问题线控失效，这个得看是不是原生的耳机，不是原生的耳机，一般会出现其他奇奇怪怪的问题（发出奇葩的信号），还有蓝牙耳机问题，等等的。具体这方便我接触到的也不多。</p>
<h2 id="UI常规问题">UI常规问题</h2>
<p>这个问题一般最不愿意避免，比如android有那么多那么多的手机型号！想想iphone还真幸运，哎不吐槽了，各种出现奇葩的显示，UI改适配得拿手机一个个调试，好伤心的。</p>
<h2 id="持久化问题：">持久化问题：</h2>
<p>一些设置没有持久化，关机之后就回复默认了，那么就得查下参数了。</p>
<h2 id="分享类问题">分享类问题</h2>
<p>这个也是经常会出现问题的，分享到外部，接口有错误！这个最严重，还有就微信分享，微博分享！经常会动不动封我们的接口！蛋疼</p>
<h2 id="待补充…-">待补充…..</h2>
<p><code>吐槽了这么，哎，总算记录完了，以后要写4篇日志以上/week  ！</code></p>
]]></content>
    <summary type="html"><![CDATA[<p>先小小的自我介绍下，以前从来没有在互联网公司实习。从14.04.09号开始在XXX音乐Android端QA实习，至今也快实习了4个月整了，现在听着同学们说做QA真的学不到什么东西，但是我觉得呢，做什么都能学到东西，关键是一个态度问题。当然，这个学习也要做一个定期的review，不然真的会造成一个没有学到任何东西的情况，下面我就给自己遇到的一些奇葩以及常规的问题做一些自己的总结:]]></summary>
    
      <category term="工作" scheme="http://zhushiqing.github.io/categories/%E5%B7%A5%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[面试小结-7.30]]></title>
    <link href="http://zhushiqing.github.io/2014/07/30/interview2/"/>
    <id>http://zhushiqing.github.io/2014/07/30/interview2/</id>
    <published>2014-07-30T09:29:28.000Z</published>
    <updated>2014-09-10T23:46:51.000Z</updated>
    <content type="html"><![CDATA[<p>每次出门都特别被，恩，说的大概就是我了吧。一路公交到面试地点，公司空调已挂，人已沙丁鱼，the result is 中暑。<br>好吧，华丽丽的想吐，真的不想吐槽我自己了，最后阶段给老奶奶让座攒攒人品，恩。废话不说。接入正题。</p>
<p>实习面试的公司背景：</p>
<p>全是技术党，很华丽的学术背景，恩，应该是实力比较强的那种，偏底层。<br><a id="more"></a></p>
<hr>
<p>面试官是高了好多届的学长。和蔼中带着气场，抛出的问题如下：</p>
<blockquote>
<p>1  能不能谈一下你对集合的理解<br>2    ArrayList底层怎么实现，HashMap底层怎么实现<br>3    list.add方法的底层实现<br>4    多线程是一种什么东西，为什么要有多线程，单核时代的多线程<br>5    用自己的方法来设计一个HashMap<br>6     jsp与ajax的关系？servlet与filter的区别<br>7    一致性哈希算法<br>8    快排<br>9     Linkedlist为什么会插入删除会比其他线性高，为什么？你有做过测试吗？<br>10 String为什么是final类？<br>11 匿名内部类调用外部变量，为什么要用final？</p>
</blockquote>
<hr>
<h3 id="我的回答如下，恩，还是很多需要改进的地方的">我的回答如下，恩，还是很多需要改进的地方的</h3>
<h3 id="Q1:">Q1:</h3>
<p>在我的眼里集合就是一个容器，主要由list与set两个抽象类，然后分别是他们两的子类，具体的map布属于collection<br>。像list是有序，允许重复，而set存的无序，不允许重复。</p>
<hr>
<h3 id="Q2、3、5:">Q2、3、5:</h3>
<ol>
<li><p>ArrayList概述：<br>ArrayList是List接口的可变数组的实现。实现了所有可选列表操作，并允许包括 null 在内的所有元素。除了实现<br>List 接口外，此类还提供一些方法来操作内部用来存储列表的数组的大小。<br>每个ArrayList实例都有一个容量，该容量是指用来存储列表元素的数组的大小。<br>它总是至少等于列表的大小。随着向ArrayList中不断添加元素，其容量也自动增长。自动增长会带来数据向新数组的<br>重新拷贝，因此，如果可预知数据量的多少，可在构造ArrayList时指定其容量。在添加大量元素前，应用程序也可以<br>使用ensureCapacity操作来增加ArrayList实例的容量，这可以减少递增式再分配的数量。<br>注意，此实现不是同步的。如果多个线程同时访问一个ArrayList实例，而其中至少一个线程从结构上修改了列表，<br>那么它必须保持外部同步。</p>
<p>arraylist.add方法：每次都是想数组的最后一个插入数据，当然也可以指定插入的地方，当数组容量不够的时候，<br>会调用下面的方法。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span>(<span class="keyword">int</span> minCapacity) {   </div><div class="line"> 	modCount++;   </div><div class="line"> 	<span class="keyword">int</span> oldCapacity = elementData.length;   </div><div class="line"> 	<span class="keyword">if</span> (minCapacity &gt; oldCapacity) {   </div><div class="line">     	Object oldData[] = elementData;   </div><div class="line">     	<span class="keyword">int</span> newCapacity = (oldCapacity * <span class="number">3</span>)/<span class="number">2</span> + <span class="number">1</span>;   </div><div class="line">         <span class="keyword">if</span> (newCapacity &lt; minCapacity)   </div><div class="line">             newCapacity = minCapacity;   </div><div class="line">   <span class="comment">// minCapacity is usually close to size, so this is a win:   </span></div><div class="line">   	elementData = Arrays.copyOf(elementData, newCapacity);   </div><div class="line"> 	}   </div><div class="line"> }</div><div class="line"> 这段是jdk里面扒出来的，从上面的代码可以看到，每次如果超过容量的时候，就是重新开辟一个<span class="number">1.5</span>-<span class="number">1</span>大小的数组，</div><div class="line"> 然后把原数组的数据copy进新数组里面去，（arraylist初始容量默认是<span class="number">10</span>）  </div><div class="line"> 很明显 这个效率非常不高吗= =。插入删除当然最要不要用arraylist了</div></pre></td></tr></table></figure>

<ol>
<li>HashMap：</li>
</ol>
<p>在我理解中，hashmap底层是一个数组实现的，每个数组的元素就是一个链表的头，映射表结合了数组查询迅速与链表插入<br>快速的优点。当我们往hashmap中put元素的时候，先根据key的hash值得到这个元素在数组中的位置（即下标），然后就<br>可以把这个元素放到对应的位置中了。如果这个元素所在的位子上已经存放有其他元素了，那么在同一个位子上的元素将以<br>链表的形式存放，新加入的放在链头，最先加入的放在链尾。从hashmap中get元素时，首先计算key的hashcode，找到数<br>组中对应位置的某一元素，然后通过key的equals方法在对应位置的链表中找到需要的元素。从这里我们可以想象得到，如<br>果每个位置上的链表只有一个元素，那么hashmap的get效率将是最高的，但是理想总是美好的，现实总是残酷的！嘿嘿</p>
<p>一般来说，只有hashmap的加载因子是0.75，也就是16个，你存了12个，那么就会进行重新扩充2倍（记住这个是一个非<br>常耗性能的操作，所有的数据都被重新计算hashcode值再散列！）</p>
<p>hashcode与equal重写。。。。</p>
<hr>
<h3 id="Q4：">Q4：</h3>
<p>师兄的意思我大体理解了下：他有问多线程具体是怎么样的。其实key应该是在于资源共享，而不是提高执行效率，最关键<br>应该是回答多线程可以提高资源使用效率而提高整个程序的执行效率。<br>线程内共享资源还是可以复习下的。</p>
<hr>
<h3 id="Q6：">Q6：</h3>
<p>jsp是服务器端语言ajax是客户端语言。</p>
<p>以前总以为filter就是一种特殊servlet，所以他们在web.xml中配置因该是一样的，但是事实并非如此！= =</p>
<p>filter是一个可以复用的代码片段，可以用来转换HTTP请求、响应和头信息。Filter不像Servlet，<br>它不能产生一个请求或者响应，它只是修改对某一资源的请求，或者修改从某一的响应。 </p>
<p>public interface filter 没有继承servlet 所以压根不是一类，囧囧的答错了。</p>
<hr>
<h3 id="Q7：">Q7：</h3>
<p>这个由于本人没接触过分布式- -只能很遗憾的答不上来。坑啊</p>
<hr>
<h3 id="Q8：">Q8：</h3>
<p>快排神马的实在是太简单了 ，这里就不说了。</p>
<hr>
<h3 id="Q9：">Q9：</h3>
<p>师兄问这个的目的就是想让我明白，做神马事情都要自己亲手做过测试才能下结论= =<br>不要老看blog怎么说的。。。你就神马都不做。</p>
<hr>
<h3 id="Q10:">Q10:</h3>
<p>主要是为了“效率” 和 “安全性” 的缘故。若 String允许被继承, 由于它的高度被使用率<br>, 可能会降低程序的性能，所以String被定义成final。</p>
<hr>
<h3 id="Q11:">Q11:</h3>
<p>从编译器的角度来看，其实内部类编译的时候已经生产的是outter$inner.class，是单独的一个文件，<br>所以用的field也是从方法内copy进来的，如果在内部类里面改掉该field也不会改变。所以为了保持值的一致性<br>所以用final修饰。</p>
<hr>
<p>今天又学到好多东西！</p>
]]></content>
    <summary type="html"><![CDATA[<p>每次出门都特别被，恩，说的大概就是我了吧。一路公交到面试地点，公司空调已挂，人已沙丁鱼，the result is 中暑。<br>好吧，华丽丽的想吐，真的不想吐槽我自己了，最后阶段给老奶奶让座攒攒人品，恩。废话不说。接入正题。</p>
<p>实习面试的公司背景：</p>
<p>全是技术党，很华丽的学术背景，恩，应该是实力比较强的那种，偏底层。<br>]]></summary>
    
      <category term="面试" scheme="http://zhushiqing.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[二分插入排序(java版本)]]></title>
    <link href="http://zhushiqing.github.io/2014/07/27/binaryinsertsort/"/>
    <id>http://zhushiqing.github.io/2014/07/27/binaryinsertsort/</id>
    <published>2014-07-27T12:31:41.000Z</published>
    <updated>2014-08-29T00:56:59.000Z</updated>
    <content type="html"><![CDATA[<h2 id="二分插入排序属于插入排序的一种">二分插入排序属于插入排序的一种</h2>
<h2><a id="more"></a></h2>
<h2 id="实现原理">实现原理</h2>
<p>其实二分插入排序的实现原理跟插入排序差不多，都是在一个数组里面，把第一个视为<br>有序的子序列，然后把后半部分视为无序的序列，后半部分就像从牌堆里面抓牌一样，<br>把循环到的元素按照有序的方式插入前面已经有序的子序列里面。<br>与直接插入排序区别就在寻找插入的位置的时候，使用了二分查找<br>来代替了从后向前遍历。从而减少搜索次数，</p>
<hr>
<h2 id="时间复杂度与稳定性">时间复杂度与稳定性</h2>
<p>二分插入排序是一种稳定的排序算法，最好情况下的时间复杂度为O(N),最坏情况下的<br>时间复杂度为O(n^2),平均也为O(n^2)</p>
<hr>
<h2 id="代码实现">代码实现</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> zju.zsq.binarysort;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.junit.Test;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySort</span> </span>{</div><div class="line">	<span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">binaryInsertSort</span>(<span class="keyword">int</span>[] data) {  </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; data.length; i++) {  </div><div class="line">            <span class="keyword">if</span> (data[i] &lt; data[i - <span class="number">1</span>]) {  </div><div class="line">                <span class="comment">// 缓存i处的元素值  </span></div><div class="line">                <span class="keyword">int</span> tmp = data[i];  </div><div class="line">                <span class="comment">// 记录搜索范围的左边界  </span></div><div class="line">                <span class="keyword">int</span> low = <span class="number">0</span>;  </div><div class="line">                <span class="comment">// 记录搜索范围的右边界  </span></div><div class="line">                <span class="keyword">int</span> high = i - <span class="number">1</span>;  </div><div class="line">                <span class="keyword">while</span> (low &lt;= high) {  </div><div class="line">                    <span class="comment">// 记录中间位置  </span></div><div class="line">                    <span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>;  </div><div class="line">                    <span class="comment">// 比较中间位置数据和i处数据大小，以缩小搜索范围  </span></div><div class="line">                    <span class="keyword">if</span> (data[mid] &lt; tmp) {  </div><div class="line">                        low = mid + <span class="number">1</span>;  </div><div class="line">                    } <span class="keyword">else</span> {  </div><div class="line">                        high = mid - <span class="number">1</span>;  </div><div class="line">                    }  </div><div class="line">                }  </div><div class="line">                <span class="comment">//将low~i处数据整体向后移动1位  </span></div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt; low; j--) {  </div><div class="line">                    data[j] = data[j - <span class="number">1</span>];  </div><div class="line">                }  </div><div class="line">                data[low] = tmp;  </div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> number : data) {</div><div class="line">    				System.out.print(number + <span class="string">" "</span>);</div><div class="line">    			}</div><div class="line">    			System.out.println();</div><div class="line">            }  </div><div class="line">        }  </div><div class="line">    }  </div><div class="line">	</div><div class="line"></div><div class="line">	<span class="annotation">@Test</span></div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBubbleSort</span>() {</div><div class="line">		<span class="keyword">int</span>[] nums = { <span class="number">1</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">11</span>, <span class="number">10</span> };</div><div class="line">		binaryInsertSort(nums);</div><div class="line">		System.out.println(<span class="string">"排序之后："</span>);</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> num : nums) {</div><div class="line">			System.out.print(num + <span class="string">" "</span>);</div><div class="line">		}</div><div class="line">	}</div><div class="line"></div><div class="line">}</div><div class="line">结果输出为：</div><div class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">7</span> <span class="number">4</span> <span class="number">5</span> <span class="number">5</span> <span class="number">9</span> <span class="number">8</span> <span class="number">11</span> <span class="number">10</span> </div><div class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">4</span> <span class="number">7</span> <span class="number">5</span> <span class="number">5</span> <span class="number">9</span> <span class="number">8</span> <span class="number">11</span> <span class="number">10</span> </div><div class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">7</span> <span class="number">5</span> <span class="number">9</span> <span class="number">8</span> <span class="number">11</span> <span class="number">10</span> </div><div class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">5</span> <span class="number">7</span> <span class="number">9</span> <span class="number">8</span> <span class="number">11</span> <span class="number">10</span> </div><div class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">5</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">11</span> <span class="number">10</span> </div><div class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">5</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span> <span class="number">11</span> </div><div class="line">排序之后:</div><div class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">5</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span> <span class="number">11</span></div></pre></td></tr></table></figure>

]]></content>
    <summary type="html"><![CDATA[<h2 id="二分插入排序属于插入排序的一种">二分插入排序属于插入排序的一种</h2>
<h2>]]></summary>
    
      <category term="Algorithms" scheme="http://zhushiqing.github.io/categories/Algorithms/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[算法之简单选择排序（java版本）]]></title>
    <link href="http://zhushiqing.github.io/2014/07/25/selectSort/"/>
    <id>http://zhushiqing.github.io/2014/07/25/selectSort/</id>
    <published>2014-07-25T12:22:30.000Z</published>
    <updated>2014-08-25T12:28:05.000Z</updated>
    <content type="html"><![CDATA[<h2 id="排序算法之简单排序算法">排序算法之简单排序算法</h2>
<a id="more"></a>

<h2 id="算法原理">算法原理</h2>
<p>//原理：每次都找到当次最大的数，按大小顺序依次放入数组相应位置<br>//比如：第一次先找到最大的数并记下其位置，如果其不在数组第一位，<br>//则将其与第一位交换，使最大数置于第一位<br>//第二次再循环查找第二大的数并记下其位置，如果其不在数组第二位，<br>//则将其与第二位交换，使最大数置于第二位<br>//依次类推…………………………………..<br>//第i次再循环查找第i大的数并记下其位置，如果其不在数组第 i位，<br>//则将其与第 i位交换，使最大数置于第 i位</p>
<h2 id="时间复杂度">时间复杂度</h2>
<p>平均、最坏、最好的时间复杂度都为O（n^2）,且是不稳定的排序算法</p>
<h2 id="java代码实现">java代码实现</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> zju.zsq.selectionsort;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.junit.Test;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SeletionSort</span> </span>{</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">selectionSort</span>(<span class="keyword">int</span>[] num){</div><div class="line">		<span class="keyword">int</span> min = <span class="number">0</span>;</div><div class="line">		<span class="keyword">int</span> temp = <span class="number">0</span>;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num.length; i++) {</div><div class="line">			min = i;</div><div class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; num.length; j++) {</div><div class="line">				<span class="keyword">if</span>(num[min] &gt; num[j]){</div><div class="line">					min = j;</div><div class="line">				}</div><div class="line">			}</div><div class="line">			<span class="keyword">if</span>(i != min){</div><div class="line">				temp = num[i];</div><div class="line">				num[i] = num[min];</div><div class="line">				num[min] = temp;</div><div class="line">			}</div><div class="line">		}</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="annotation">@Test</span></div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSelectionSort</span>(){</div><div class="line">		<span class="keyword">int</span>[] nums = {<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">11</span>,<span class="number">6</span>};</div><div class="line">		selectionSort(nums);</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> num : nums){</div><div class="line">			System.out.print(num+<span class="string">" "</span>);</div><div class="line">		}</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">//输出如下：</span></div><div class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">11</span></div></pre></td></tr></table></figure>

<p>简单选择排序是不是非常简单啊！</p>
]]></content>
    <summary type="html"><![CDATA[<h2 id="排序算法之简单排序算法">排序算法之简单排序算法</h2>
]]></summary>
    
      <category term="排序算法" scheme="http://zhushiqing.github.io/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
      <category term="Algorithms" scheme="http://zhushiqing.github.io/categories/Algorithms/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[算法之插入排序（java版本）]]></title>
    <link href="http://zhushiqing.github.io/2014/07/25/Algorithm4/"/>
    <id>http://zhushiqing.github.io/2014/07/25/Algorithm4/</id>
    <published>2014-07-25T01:33:11.000Z</published>
    <updated>2014-08-24T04:41:38.000Z</updated>
    <content type="html"><![CDATA[<p>插入排序也是最常见的排序之一，他分为以下几种   </p>
<blockquote>
<p>1 直接插入排序<br>2 二分插入排序<br>3 希尔插入排序<br>4 链表插入排序</p>
</blockquote>
<hr>
<a id="more"></a>


<h2 id="实现原理">实现原理</h2>
<p>跟抓牌一样，自己先定义一个有序区域，把抓到的牌放到已经排好序的牌堆里面，直到所有牌都抓完，有序区域就变成了整个<br>牌。<br>也就是说假设前面(n-1) [n&gt;=2]个数已经是排<br>好顺序的，现在要把第n个数插到前面的有序数中，使得这n个数<br>也是排好顺序的。如此反复循环，直到全部排好顺序</p>
<h2 id="时间复杂度">时间复杂度</h2>
<p>一般来说，最好情况下的插入排序时间复杂度为O(n),平均以及最坏的时间复杂度为O(n^2),而且插入排序是最稳定的排序<br>算法，在数据量小的情况下，插入排序的效率挺高的- -。</p>
<p>下面让我用java代码实现下直接插入排序。</p>
<h2 id="代码实现直接排序">代码实现直接排序</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Insertion</span> </span>{  </div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertionSort</span>(<span class="keyword">int</span> []num){  </div><div class="line">    	<span class="keyword">int</span> temp = <span class="number">0</span>;</div><div class="line">       	</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;num.length;i++){</div><div class="line">       		<span class="keyword">int</span> j=i-<span class="number">1</span>;</div><div class="line">      		temp=a[i];</div><div class="line">		<span class="keyword">while</span>(j &gt;= <span class="number">0</span>&&temp &lt; a[j]){</div><div class="line">       			a[j+<span class="number">1</span>] = a[j];                <span class="comment">//将大于temp的值整体后移一个单位</span></div><div class="line">       			j--;</div><div class="line">       		}</div><div class="line">       		a[j+<span class="number">1</span>] = temp;</div><div class="line">    	}</div><div class="line">    }  </div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String []args){  </div><div class="line">        <span class="keyword">int</span>[] num={<span class="number">4</span>,<span class="number">9</span>,<span class="number">23</span>,<span class="number">1</span>,<span class="number">45</span>,<span class="number">27</span>,<span class="number">5</span>,<span class="number">2</span>};  </div><div class="line">        insertionSort(num);  </div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num.length;i++)  </div><div class="line">            System.out.println(<span class="string">"插入排序后："</span>+num[i]);  </div><div class="line">    }  </div><div class="line">}</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html"><![CDATA[<p>插入排序也是最常见的排序之一，他分为以下几种   </p>
<blockquote>
<p>1 直接插入排序<br>2 二分插入排序<br>3 希尔插入排序<br>4 链表插入排序</p>
</blockquote>
<hr>
]]></summary>
    
      <category term="Algorithms" scheme="http://zhushiqing.github.io/categories/Algorithms/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[算法之快排（java版本）]]></title>
    <link href="http://zhushiqing.github.io/2014/07/24/Algorithm2/"/>
    <id>http://zhushiqing.github.io/2014/07/24/Algorithm2/</id>
    <published>2014-07-24T00:01:45.000Z</published>
    <updated>2014-08-26T01:39:27.000Z</updated>
    <content type="html"><![CDATA[<p>快排神马的，就是各路考官最爱问的东西：<br><a id="more"></a></p>
<p>在我自己的理解中，快排是这样的：</p>
<h2 id="实现原理">实现原理</h2>
<blockquote>
<ul>
<li>1.先选择数组中的一个数，作为一个基准（一般情况下选第一个）</li>
<li>2.然后对整个数组进行第一次遍历，把小于基准的数扔到及基准数的左边，大于的数扔到右边。</li>
<li>3.一遍遍历结束后，基准左边的数都小于基准，右边都大于基准，然后以基准为界可以得到两个新数组，对新数组重复1、2步骤。</li>
<li>4.不断递归调用之后得到的数组就是有序的。</li>
</ul>
</blockquote>
<h2 id="时间复杂度">时间复杂度</h2>
<p>像一般java中Array.sort底层实现就是采用的快排，一般快排的效率都是蛮高的，但是快排最坏的情况下时间复杂度也为O(n^2)<br>,比说一组数组本身就是有序的，倒序，然后基准为第一个数，这样用快排排数组就是最坏情况下的时间复杂度，当然一般情况下平均事件复杂度都为：O(nlog(n))</p>
<h2 id="代码实现">代码实现</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuicklySort</span> </span>{</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMid</span>(<span class="keyword">int</span>[] num,<span class="keyword">int</span> low,<span class="keyword">int</span> high){</div><div class="line">		<span class="keyword">int</span> temp = num[low];</div><div class="line">		<span class="keyword">while</span>(low &lt; high){</div><div class="line">			<span class="keyword">while</span>(low &lt; high && num[high] &gt;= temp){</div><div class="line">				high--;</div><div class="line">			}</div><div class="line">			num[low] = num [high];</div><div class="line">			<span class="keyword">while</span>(low &lt; high && num[low] &lt;= temp){</div><div class="line">				low ++;</div><div class="line">			}</div><div class="line">			num[high] = num[low];</div><div class="line">		}</div><div class="line">		num [low] = temp;</div><div class="line">		<span class="keyword">return</span> low;</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">QuickSort</span>(<span class="keyword">int</span>[] num,<span class="keyword">int</span> low,<span class="keyword">int</span> high){</div><div class="line">		<span class="keyword">if</span>(low &lt; high){</div><div class="line">			<span class="keyword">int</span> mid = getMid(num, low, high);</div><div class="line">			QuickSort(num,mid+<span class="number">1</span>,high);</div><div class="line">			QuickSort(num,low,mid-<span class="number">1</span>);</div><div class="line">		}</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span>(<span class="keyword">int</span>[] num){</div><div class="line">		<span class="keyword">if</span>(num.length &gt; <span class="number">0</span>){</div><div class="line">			QuickSort(num,<span class="number">0</span>,num.length-<span class="number">1</span>);</div><div class="line">		}</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="annotation">@Test</span></div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoSort</span>(){</div><div class="line">		<span class="keyword">int</span> num[] = {<span class="number">1</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">11</span>};</div><div class="line">		sort(num);</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num.length; i++) {</div><div class="line">			System.out.println(num[i]);</div><div class="line">		}</div><div class="line">	}</div></pre></td></tr></table></figure>

<h3 id="其实针对最坏时间复杂度其实还有更好的解法：随机快排">其实针对最坏时间复杂度其实还有更好的解法：随机快排</h3>
<hr>
<p>随机定义那个基准数，就是大家所称的随机化快排，也是快排的一种变种，<br>我记得我曾看到一句戏言，这样的随机化快排遇到最坏的时间复杂度的几率只有1/(2^n),只够满足人一生的人品需求。</p>
<p>还有就是一种就是平衡化快排，就是把基准数尽量可能的取为中值—-即每次取值在第一个数，中间那个数，最后一个数做<br>比较，据说这样能提高尽两倍的性能，实际上我也没尝试过，不过算法书上这样写应该没错把= =。</p>
<hr>
<p>最后说一句：算法这东西都是靠积累的，每天都要努力！come on everyone！</p>
]]></content>
    <summary type="html"><![CDATA[<p>快排神马的，就是各路考官最爱问的东西：<br>]]></summary>
    
      <category term="Algorithms" scheme="http://zhushiqing.github.io/categories/Algorithms/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[算法之冒泡（java版本）]]></title>
    <link href="http://zhushiqing.github.io/2014/07/22/Algorithm1/"/>
    <id>http://zhushiqing.github.io/2014/07/22/Algorithm1/</id>
    <published>2014-07-22T13:20:03.000Z</published>
    <updated>2014-08-24T02:58:28.000Z</updated>
    <content type="html"><![CDATA[<h2 id="实现原理">实现原理</h2>
<p>冒泡排序是最基础的排序算法，就像水底的气泡一个个冒出来一样。<br>冒泡排序算法的运作如下：（从后往前）—-参考百科<br><a id="more"></a></p>
<blockquote>
<ul>
<li>1.比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li>
<li>2.对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。</li>
<li>3.针对所有的元素重复以上的步骤，除了最后一个。</li>
<li>4.持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li>
</ul>
</blockquote>
<h2 id="时间复杂度">时间复杂度</h2>
<p>总的来说，像冒泡排序最理想的时间复杂度为O(n)，这个是在本身数据有序的情况下，<br>最坏情况的事件复杂度是O(n^2),平均的时间复杂度也为O(n^2)，接下来让我们来看看java版本的代码实现吧：</p>
<h2 id="代码实现">代码实现</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BubbleSort</span></span></div><div class="line">{</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args){</div><div class="line">		<span class="keyword">int</span>[] num = {<span class="number">705</span>,<span class="number">826</span>,<span class="number">680</span>,<span class="number">654</span>,<span class="number">694</span>};</div><div class="line">		<span class="keyword">int</span> temp;<span class="comment">//临时变量</span></div><div class="line">		<span class="comment">//第一个循环控制比较的轮数</span></div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; num.length - <span class="number">1</span>;i++){</div><div class="line">			<span class="comment">//第二个循环控制每轮比较的次数</span></div><div class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; num.length - <span class="number">1</span> - i; j++){</div><div class="line">				<span class="keyword">if</span>(num[j] &gt; num[j + <span class="number">1</span>]){</div><div class="line">					temp = num[j];</div><div class="line">					num[j] = num[j + <span class="number">1</span>];</div><div class="line">					num[j + <span class="number">1</span>] = temp;</div><div class="line">				}</div><div class="line">			}</div><div class="line">		}</div><div class="line">		System.out.println(<span class="string">"使用冒泡排序后的数列是"</span>);</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; num.length; i++){</div><div class="line">			System.out.println(num[i]+<span class="string">" "</span> );</div><div class="line">		}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">	}</div><div class="line">}</div><div class="line">输出以及过程如下：</div><div class="line"><span class="comment">/*</span></div><div class="line">705,826,680,654,694</div><div class="line">705,680,654,694,826  第一轮</div><div class="line">680,654,694,705,826  第二轮</div><div class="line">654,680,694,705,826</div><div class="line">654,680,694,705,826</div><div class="line">*/</div></pre></td></tr></table></figure>

<hr>
<p>最简单的也是基础的也是最会被问的，与诸君共勉。</p>
]]></content>
    <summary type="html"><![CDATA[<h2 id="实现原理">实现原理</h2>
<p>冒泡排序是最基础的排序算法，就像水底的气泡一个个冒出来一样。<br>冒泡排序算法的运作如下：（从后往前）—-参考百科<br>]]></summary>
    
      <category term="算法基础" scheme="http://zhushiqing.github.io/tags/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
    
      <category term="Algorithms" scheme="http://zhushiqing.github.io/categories/Algorithms/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[算法之二分查找(java版本)]]></title>
    <link href="http://zhushiqing.github.io/2014/07/21/Algorithm3/"/>
    <id>http://zhushiqing.github.io/2014/07/21/Algorithm3/</id>
    <published>2014-07-21T00:57:38.000Z</published>
    <updated>2014-08-24T02:59:16.000Z</updated>
    <content type="html"><![CDATA[<h2 id="时间复杂度">时间复杂度</h2>
<p>怎么说呢。二分查找优缺点都是很明显的：<br><strong>优点</strong>：就是查找的平均性能高，事件复杂度只有O（log（n））。但是<strong>缺点</strong>他也是<br>非常明显的，被查找的数组必须是有序的。<br><em>所以他最好是用于不经常变动但是查找频繁的数组</em><br><a id="more"></a></p>
<h2 id="实现原理">实现原理</h2>
<p>在我的理解中：</p>
<p>1.拿要找的数与数组的中间数做比较，如果数组中的数大于就取0，到中值为新数组，否则则是（mid，last）作为新数组<br>2.拿新数组重复1步骤<br>3.重复1，2步骤直到找到那个值</p>
<h2 id="代码实现">代码实现</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span>(<span class="keyword">int</span>[] x, <span class="keyword">int</span> n){</div><div class="line">	<span class="keyword">int</span> start = <span class="number">0</span>;</div><div class="line">	<span class="keyword">int</span> mid = -<span class="number">1</span>;</div><div class="line">	<span class="keyword">int</span> end = x.length - <span class="number">1</span>;</div><div class="line">	<span class="keyword">while</span>(start &lt;= end){</div><div class="line">		mid = (start + end)/<span class="number">2</span>;</div><div class="line">		<span class="keyword">if</span>(x[mid] == n){</div><div class="line">			<span class="keyword">return</span> mid;</div><div class="line">		}<span class="keyword">else</span> <span class="keyword">if</span>(x[mid] &gt; n){</div><div class="line">			end = mid - <span class="number">1</span>;</div><div class="line">		}<span class="keyword">else</span> <span class="keyword">if</span>(x[mid] &lt; n){</div><div class="line">			start = mid + <span class="number">1</span>;</div><div class="line">		}</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {</div><div class="line">			</div><div class="line">	<span class="keyword">int</span>[] nums = {<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">11</span>,<span class="number">45</span>,<span class="number">89</span>,<span class="number">102</span>,<span class="number">99</span>,<span class="number">47</span>,<span class="number">66</span>};</div><div class="line">	Arrays.sort(nums);</div><div class="line">		</div><div class="line">	<span class="comment">//</span></div><div class="line">	<span class="keyword">int</span> index = binarySearch(nums,<span class="number">47</span>);</div><div class="line">	System.out.println(index);</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这样就是一个简单的实现了。</p>
<hr>
<h2 id="积累是一种习惯！">积累是一种习惯！</h2>
]]></content>
    <summary type="html"><![CDATA[<h2 id="时间复杂度">时间复杂度</h2>
<p>怎么说呢。二分查找优缺点都是很明显的：<br><strong>优点</strong>：就是查找的平均性能高，事件复杂度只有O（log（n））。但是<strong>缺点</strong>他也是<br>非常明显的，被查找的数组必须是有序的。<br><em>所以他最好是用于不经常变动但是查找频繁的数组</em><br>]]></summary>
    
      <category term="Algorithms" scheme="http://zhushiqing.github.io/categories/Algorithms/"/>
    
  </entry>
  
</feed>
